<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCENSION PROTOCOL v3.2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #titleScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a, #1a0a2a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #titleScreen h1 {
            font-size: 64px;
            color: #00ffff;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            margin-bottom: 50px;
            animation: titlePulse 2s infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .menuButton {
            width: 200px;
            padding: 15px;
            margin: 10px;
            font-size: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .menuButton:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        #rankingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a, #1a0a2a);
            display: none;
            color: #fff;
            z-index: 999;
        }
        
        #rankingScreen h2 {
            text-align: center;
            color: #00ffff;
            font-size: 48px;
            margin: 30px 0;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        #rankingList {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            padding: 0 50px 50px 50px;
        }
        
        #rankingList::-webkit-scrollbar {
            width: 10px;
        }
        
        #rankingList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
        }
        
        #rankingList::-webkit-scrollbar-thumb {
            background: #00ffff;
            border-radius: 5px;
        }
        
        .rankingEntry {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 15px 20px;
            margin: 10px auto;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }
        
        .rankingEntry:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateX(10px);
        }
        
        .rankingEntry .rank {
            font-size: 28px;
            color: #ffff00;
            min-width: 60px;
        }
        
        .rankingEntry.top3 .rank {
            color: #ff6600;
            font-weight: bold;
        }
        
        .rankingEntry .name {
            font-size: 22px;
            color: #00ffff;
            min-width: 120px;
        }
        
        .rankingEntry .stats {
            display: flex;
            gap: 30px;
            flex-grow: 1;
            justify-content: center;
        }
        
        .rankingEntry .skills {
            display: flex;
            gap: 10px;
        }
        
        .backButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            color: #ff0000;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .backButton:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1);
        }
        
        #gameContainer {
            position: relative;
            background: #000;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            display: none;
            width: 800px;
            height: 600px;
        }
        
        #gameCanvas {
            border: 2px solid #00ffff;
            cursor: none;
        }
        
        #ui {
            position: absolute;
            top: -60px;
            left: 0;
            width: 100%;
            height: 50px;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-bottom: none;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
        }
        
        #ui > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #ui .label {
            color: #888;
            font-size: 14px;
        }
        
        #ui .value {
            color: #00ffff;
            font-weight: bold;
        }
        
        #hearts {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }
        
        .heart {
            font-size: 24px;
            color: #ff0000;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        #skillBar {
            position: absolute;
            bottom: -90px;
            left: 20px;
            display: flex;
            gap: 15px;
        }
        
        .skillSlot {
            width: 70px;
            height: 70px;
            border: 3px solid #00ffff;
            background: rgba(0, 0, 0, 0.9);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: #00ffff;
            transition: all 0.3s;
            border-radius: 10px;
        }
        
        .skillSlot.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            border-color: #00ff00;
        }
        
        .skillSlot.cooldown {
            background: rgba(50, 50, 50, 0.7);
            color: #666;
            border-color: #666;
        }
        
        .skillSlot .cooldownOverlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 255, 255, 0.3);
            transition: height 0.1s linear;
            border-radius: 0 0 7px 7px;
        }
        
        .skillSlot .keyLabel {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: #00ffff;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.9);
            padding: 2px 8px;
            border: 1px solid #00ffff;
            border-radius: 5px;
        }
        
        .skillSlot .skillIcon {
            font-size: 35px;
        }
        
        #levelUpModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.95));
            border: 2px solid #00ffff;
            padding: 20px;
            display: none;
            text-align: center;
            color: #fff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            max-width: 600px;
            z-index: 100;
        }
        
        .upgradeOption {
            margin: 10px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .upgradeOption:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        .upgradeOption.ultimate {
            border-color: #ff00ff;
            background: rgba(255, 0, 255, 0.1);
        }
        
        .upgradeOption.ultimate:hover {
            background: rgba(255, 0, 255, 0.3);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }
        
        #gameOverModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff0000;
            padding: 30px;
            display: none;
            text-align: center;
            color: #fff;
            z-index: 100;
        }
        
        .gameOverButtons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .gameOverButton {
            padding: 10px 30px;
            background: #ff0000;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .gameOverButton:hover {
            background: #ff4444;
            transform: scale(1.1);
        }
        
        .gameOverButton.secondary {
            background: #666;
        }
        
        .gameOverButton.secondary:hover {
            background: #888;
        }
        
        .skillLevelIndicator {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 14px;
            color: #ffff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- „Çø„Ç§„Éà„É´ÁîªÈù¢ -->
    <div id="titleScreen">
        <h1>ASCENSION PROTOCOL</h1>
        <button class="menuButton" onclick="startGame()">START</button>
        <button class="menuButton" onclick="showRanking()">RANKING</button>
        <button class="menuButton" onclick="showSettings()">SETTINGS</button>
    </div>
    
    <!-- „É©„É≥„Ç≠„É≥„Ç∞ÁîªÈù¢ -->
    <div id="rankingScreen">
        <button class="backButton" onclick="backFromRanking()">‚Üê BACK</button>
        <h2>TOP PILOTS</h2>
        <div id="rankingList"></div>
    </div>
    
    <!-- „Ç≤„Éº„É†ÁîªÈù¢ -->
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>
                <span class="label">SCORE</span>
                <span class="value" id="score">0</span>
            </div>
            <div>
                <span class="label">LEVEL</span>
                <span class="value" id="level">1</span>
            </div>
            <div>
                <span class="label">EXP</span>
                <span class="value"><span id="exp">0</span>/<span id="expNeeded">100</span></span>
            </div>
            <div>
                <span class="label">TIME</span>
                <span class="value" id="time">0:00</span>
            </div>
            <div id="hearts"></div>
        </div>
        
        <div id="skillBar"></div>
        
        <div id="levelUpModal">
            <h2>LEVEL UP!</h2>
            <p id="levelUpMessage">Choose your upgrade:</p>
            <div id="upgradeOptions"></div>
        </div>
        
        <div id="gameOverModal">
            <h2>GAME OVER</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Level Reached: <span id="finalLevel">0</span></p>
            <p>Time Survived: <span id="finalTime">0:00</span></p>
            <div class="gameOverButtons">
                <button class="gameOverButton" onclick="retryGame()">RETRY</button>
                <button class="gameOverButton secondary" onclick="backToTitle()">TITLE</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // „Ç≤„Éº„É†Áä∂ÊÖã
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            level: 1,
            exp: 0,
            expNeeded: 100,
            time: 0,
            deathAnimating: false,
            enemySpawnReduction: false,
            firstBlueSpawned: false,
            lastBlueSpawnTime: 0
        };
        
        // „Éó„É¨„Ç§„É§„Éº
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            size: 20,
            lives: 5,
            maxLives: 5,
            invulnerable: 0,
            speed: 5,
            damage: 10,
            fireRate: 2.5,
            upgrades: {
                baseSpeed: 0,
                baseDamage: 0,
                baseFireRate: 0,
                healCount: 0
            },
            skills: {
                Q: null,
                W: null,
                E: null,
                R: null
            },
            basicSkillCount: 0
        };
        
        // „Çπ„Ç≠„É´ÂÆöÁæ©
        const skills = {
            // Âü∫Êú¨„Çπ„Ç≠„É´
            spreadShot: {
                id: 'spreadShot',
                name: 'Spread Shot',
                description: 'Fire bullets in a fan pattern',
                icon: '‚ö°',
                type: 'basic',
                level: 0,
                maxLevel: 6,
                baseDuration: 15000,
                duration: 15000,
                baseCooldown: 20000,
                cooldown: 20000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                effect: () => {},
                levelBonus: {
                    5: 'Bullets increased from 3 to 5'
                }
            },
            laserBeam: {
                id: 'laserBeam',
                name: 'Giant Shot',
                description: 'Triple bullet size & double damage',
                icon: '‚¨§',
                type: 'basic',
                level: 0,
                maxLevel: 6,
                baseDuration: 12000,
                duration: 12000,
                baseCooldown: 18000,
                cooldown: 18000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                effect: () => {},
                levelBonus: {
                    5: 'Bullet size x4 & damage x3'
                }
            },
            rapidFire: {
                id: 'rapidFire',
                name: 'Rapid Fire',
                description: 'Double fire rate',
                icon: 'üî•',
                type: 'basic',
                level: 0,
                maxLevel: 6,
                baseDuration: 8000,
                duration: 8000,
                baseCooldown: 20000,
                cooldown: 20000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                fireRateMultiplier: 2,
                effect: () => {},
                levelBonus: {
                    5: 'Fire rate x3 instead of x2'
                }
            },
            dash: {
                id: 'dash',
                name: 'Dash',
                description: 'Quick dash movement',
                icon: '‚Üí',
                type: 'basic',
                level: 0,
                maxLevel: 6,
                baseCooldown: 10000,
                cooldown: 10000,
                charges: 1,
                maxCharges: 1,
                lastUsed: 0,
                effect: () => {
                    performDash();
                },
                levelBonus: {
                    5: '2 charge stacks'
                }
            },
            barrier: {
                id: 'barrier',
                name: 'EM Barrier',
                description: 'Generate protective barrier',
                icon: '‚óØ',
                type: 'basic',
                level: 0,
                maxLevel: 6,
                baseDuration: 5000,
                duration: 5000,
                baseCooldown: 20000,
                cooldown: 20000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                radius: 50,
                effect: () => {},
                levelBonus: {
                    5: 'Range x1.5'
                }
            },
            // „Ç¢„É´„ÉÜ„Ç£„É°„ÉÉ„Éà„Çπ„Ç≠„É´
            invincible: {
                id: 'invincible',
                name: 'Invincibility',
                description: 'Become invulnerable',
                icon: 'üõ°Ô∏è',
                type: 'ultimate',
                level: 10,
                baseDuration: 10000,
                duration: 10000,
                baseCooldown: 60000,
                cooldown: 60000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                effect: () => {}
            },
            ricochet: {
                id: 'ricochet',
                name: 'Ricochet',
                description: 'Bullets bounce 3 times',
                icon: '‚Üó',
                type: 'ultimate',
                level: 10,
                baseDuration: 15000,
                duration: 15000,
                baseCooldown: 60000,
                cooldown: 60000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                effect: () => {}
            },
            homing: {
                id: 'homing',
                name: 'Homing',
                description: 'All bullets home in on enemies',
                icon: 'üéØ',
                type: 'ultimate',
                level: 10,
                baseDuration: 12000,
                duration: 12000,
                baseCooldown: 60000,
                cooldown: 60000,
                active: false,
                lastUsed: 0,
                activatedAt: 0,
                effect: () => {}
            }
        };
        
        // ÈÖçÂàó
        let bullets = [];
        let enemies = [];
        let particles = [];
        let expOrbs = [];
        let stars = [];
        let blueEnemyCount = 0;
        
        // ÂÖ•ÂäõÁä∂ÊÖã
        const keys = {};
        let mouseX = player.x;
        let mouseY = player.y;
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®
        let animationId = null;
        let dashChargeInterval = null;
        
        // „ÉÄ„Éü„Éº„É©„É≥„Ç≠„É≥„Ç∞„Éá„Éº„ÇøÔºà15ÂÄãÔºâ
        const dummyRankings = [
            { rank: 1, name: "ACE", score: 999999, time: "45:32", skills: ['‚ö°', 'üî•', '‚óØ', 'üõ°Ô∏è'] },
            { rank: 2, name: "NOVA", score: 750000, time: "38:15", skills: ['‚¨§', '‚Üí', '‚ö°', 'üéØ'] },
            { rank: 3, name: "STAR", score: 500000, time: "32:44", skills: ['üî•', '‚óØ', '‚Üí', '‚Üó'] },
            { rank: 4, name: "HAWK", score: 250000, time: "25:18", skills: ['‚ö°', '‚¨§', '‚Üí', '‚Üó'] },
            { rank: 5, name: "FALCON", score: 100000, time: "18:52", skills: ['‚óØ', 'üî•', '‚ö°', 'üõ°Ô∏è'] },
            { rank: 6, name: "PHOENIX", score: 95000, time: "17:30", skills: ['‚¨§', 'üî•', '‚óØ', 'üéØ'] },
            { rank: 7, name: "EAGLE", score: 87500, time: "16:45", skills: ['‚ö°', '‚Üí', '‚¨§', 'üéØ'] },
            { rank: 8, name: "RAPTOR", score: 75000, time: "15:20", skills: ['üî•', '‚ö°', '‚Üí', '‚Üó'] },
            { rank: 9, name: "VIPER", score: 65000, time: "14:15", skills: ['‚óØ', '‚¨§', 'üî•', 'üõ°Ô∏è'] },
            { rank: 10, name: "COBRA", score: 55000, time: "13:00", skills: ['‚Üí', '‚ö°', '‚óØ', '‚Üó'] },
            { rank: 11, name: "WOLF", score: 47500, time: "11:45", skills: ['‚¨§', '‚óØ', '‚Üí', 'üéØ'] },
            { rank: 12, name: "TIGER", score: 40000, time: "10:30", skills: ['üî•', '‚Üí', '‚ö°', '‚Üó'] },
            { rank: 13, name: "LYNX", score: 32500, time: "9:15", skills: ['‚ö°', 'üî•', '‚¨§', 'üõ°Ô∏è'] },
            { rank: 14, name: "PANTHER", score: 25000, time: "8:00", skills: ['‚óØ', '‚Üí', 'üî•', 'üéØ'] },
            { rank: 15, name: "ROOKIE", score: 15000, time: "6:30", skills: ['‚ö°', '‚¨§', '‚óØ', 'üéØ'] }
        ];
        
        // „Çø„Ç§„Éà„É´ÁîªÈù¢Èñ¢Êï∞
        function showRanking() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('rankingScreen').style.display = 'block';
            
            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '';
            
            dummyRankings.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'rankingEntry';
                if (entry.rank <= 3) div.className += ' top3';
                
                div.innerHTML = `
                    <div class="rank">#${entry.rank}</div>
                    <div class="name">${entry.name}</div>
                    <div class="stats">
                        <div>Score: ${entry.score.toLocaleString()}</div>
                        <div>Time: ${entry.time}</div>
                    </div>
                    <div class="skills">
                        ${entry.skills.map(s => `<span style="font-size: 24px;">${s}</span>`).join('')}
                    </div>
                `;
                rankingList.appendChild(div);
            });
        }
        
        function backFromRanking() {
            document.getElementById('rankingScreen').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
        }
        
        function showSettings() {
            alert('SETTINGS (Coming Soon)\n\n- Sound: ON\n- Music: ON\n- Effects: HIGH');
        }
        
        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            gameState.running = true;
            init();
        }
        
        function retryGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            resetGame();
            gameState.running = true;
            gameLoop();
            spawnEnemies();
        }
        
        function backToTitle() {
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
            resetGame();
        }
        
        // Êòü„ÅÆÂàùÊúüÂåñ
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random() * 0.5 + 0.5
                });
            }
        }
        
        // Êòü„ÅÆÊõ¥Êñ∞
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = -10;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        // „Çπ„Ç≠„É´Èñ¢ÈÄ£Èñ¢Êï∞
        function updateSkillLevels(skill) {
            skill.level++;
            
            // „É¨„Éô„É´„Å´Âøú„Åò„ÅüÂäπÊûú
            const levelEffects = {
                2: () => {
                    skill.duration = skill.baseDuration * 1.2;
                },
                3: () => {
                    skill.cooldown = skill.baseCooldown * 0.8;
                },
                4: () => {
                    skill.duration = skill.baseDuration * 1.44; // 1.2 * 1.2
                },
                6: () => {
                    skill.cooldown = skill.baseCooldown * 0.64; // 0.8 * 0.8
                }
            };
            
            if (levelEffects[skill.level]) {
                levelEffects[skill.level]();
            }
            
            // „É¨„Éô„É´5„ÅÆÁâπÊÆäÂäπÊûú
            if (skill.level === 5) {
                switch (skill.id) {
                    case 'rapidFire':
                        skill.fireRateMultiplier = 3;
                        break;
                    case 'dash':
                        skill.maxCharges = 2;
                        skill.charges = 2;
                        break;
                    case 'barrier':
                        skill.radius = 75;
                        break;
                }
            }
            
            // „Ç¢„É´„ÉÜ„Ç£„É°„ÉÉ„Éà„Çπ„Ç≠„É´„ÅÆ„É¨„Éô„É´20„ÄÅ30Âº∑Âåñ
            if (skill.type === 'ultimate') {
                if (skill.level === 20) {
                    switch (skill.id) {
                        case 'invincible':
                            skill.duration = 15000;
                            break;
                        case 'ricochet':
                            skill.duration = 18000;
                            break;
                        case 'homing':
                            skill.duration = 20000;
                            break;
                    }
                } else if (skill.level === 30) {
                    switch (skill.id) {
                        case 'invincible':
                            skill.cooldown = 40000;
                            break;
                        case 'ricochet':
                            skill.cooldown = 45000;
                            break;
                        case 'homing':
                            skill.cooldown = 40000;
                            break;
                    }
                }
            }
        }
        
        function activateSkill(key) {
            const skill = player.skills[key];
            if (!skill || skill === 'empty') return;
            
            const now = Date.now();
            
            // „ÉÄ„ÉÉ„Ç∑„É•„ÅÆÁâπÊÆäÂá¶ÁêÜÔºà„ÉÅ„É£„Éº„Ç∏„Ç∑„Çπ„ÉÜ„É†Ôºâ
            if (skill.id === 'dash') {
                if (skill.charges > 0) {
                    skill.effect();
                    skill.charges--;
                    if (skill.charges === 0) {
                        skill.lastUsed = now;
                    }
                }
                return;
            }
            
            // ÈÄöÂ∏∏„Çπ„Ç≠„É´„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„ÉÅ„Çß„ÉÉ„ÇØ
            if (now - skill.lastUsed < skill.cooldown) return;
            
            skill.active = true;
            skill.lastUsed = now;
            skill.activatedAt = now;
            skill.effect();
            
            // Á∂ôÁ∂öÊôÇÈñìÂæå„Å´ÁÑ°ÂäπÂåñ
            if (skill.duration) {
                setTimeout(() => {
                    skill.active = false;
                }, skill.duration);
            }
        }
        
        function updateSkillBar() {
            const skillBar = document.getElementById('skillBar');
            skillBar.innerHTML = '';
            
            ['Q', 'W', 'E', 'R'].forEach(key => {
                const skill = player.skills[key];
                const slot = document.createElement('div');
                slot.className = 'skillSlot';
                
                if (skill && skill !== 'empty') {
                    const now = Date.now();
                    const timeSinceUse = now - skill.lastUsed;
                    const cooldownProgress = Math.min(timeSinceUse / skill.cooldown, 1);
                    
                    if (skill.active) {
                        slot.classList.add('active');
                        
                        // „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊôÇÈñì„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„ÇíË®àÁÆó
                        const activeTime = now - skill.activatedAt;
                        const activeProgress = Math.max(0, 1 - (activeTime / skill.duration));
                        
                        // „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊôÇÈñì„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§
                        const overlay = document.createElement('div');
                        overlay.className = 'cooldownOverlay';
                        overlay.style.height = `${activeProgress * 100}%`;
                        overlay.style.background = 'rgba(0, 255, 0, 0.3)';
                        slot.appendChild(overlay);
                    } else if (cooldownProgress < 1 && skill.id !== 'dash') {
                        slot.classList.add('cooldown');
                        
                        // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§
                        const overlay = document.createElement('div');
                        overlay.className = 'cooldownOverlay';
                        overlay.style.height = `${(1 - cooldownProgress) * 100}%`;
                        slot.appendChild(overlay);
                    }
                    
                    // „ÉÄ„ÉÉ„Ç∑„É•„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Ë°®Á§∫
                    if (skill.id === 'dash') {
                        if (skill.charges === 0) {
                            slot.classList.add('cooldown');
                            const timeSinceEmpty = now - skill.lastUsed;
                            const rechargeProgress = Math.min(timeSinceEmpty / skill.cooldown, 1);
                            
                            const overlay = document.createElement('div');
                            overlay.className = 'cooldownOverlay';
                            overlay.style.height = `${(1 - rechargeProgress) * 100}%`;
                            slot.appendChild(overlay);
                        } else {
                            // „ÉÅ„É£„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰ΩøÁî®ÂèØËÉΩ„Å®„Åó„Å¶Ë°®Á§∫
                            slot.classList.remove('cooldown');
                        }
                    }
                    
                    // „Ç¢„Ç§„Ç≥„É≥
                    const icon = document.createElement('div');
                    icon.className = 'skillIcon';
                    icon.textContent = skill.icon;
                    slot.appendChild(icon);
                    
                    // „É¨„Éô„É´Ë°®Á§∫
                    if (skill.level > 1) {
                        const levelIndicator = document.createElement('div');
                        levelIndicator.className = 'skillLevelIndicator';
                        levelIndicator.textContent = skill.level;
                        slot.appendChild(levelIndicator);
                    }
                    
                    // „ÉÄ„ÉÉ„Ç∑„É•„ÅÆ„ÉÅ„É£„Éº„Ç∏Êï∞Ë°®Á§∫
                    if (skill.id === 'dash' && skill.charges > 0) {
                        const charges = document.createElement('div');
                        charges.style.cssText = 'position: absolute; bottom: 2px; right: 2px; font-size: 18px; color: #ffff00;';
                        charges.textContent = skill.charges;
                        slot.appendChild(charges);
                    }
                } else {
                    slot.textContent = key === 'R' ? 'üîí' : '?';
                    slot.style.opacity = '0.5';
                }
                
                const keyLabel = document.createElement('div');
                keyLabel.className = 'keyLabel';
                keyLabel.textContent = key;
                slot.appendChild(keyLabel);
                
                skillBar.appendChild(slot);
            });
        }
        
        // „Éè„Éº„ÉàË°®Á§∫Êõ¥Êñ∞
        function updateHearts() {
            const heartsDiv = document.getElementById('hearts');
            heartsDiv.innerHTML = '';
            
            for (let i = 0; i < player.maxLives; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.textContent = i < player.lives ? '‚ù§Ô∏è' : 'üñ§';
                heartsDiv.appendChild(heart);
            }
        }
        
        // ÂàùÊúüÂåñ
        function init() {
            // Ââç„ÅÆ„Ç≤„Éº„É†„É´„Éº„Éó„Å®„Ç§„É≥„Çø„Éº„Éê„É´„Çí„ÇØ„É™„Ç¢
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (dashChargeInterval) {
                clearInterval(dashChargeInterval);
                dashChargeInterval = null;
            }
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºàÈáçË§áÈò≤Ê≠¢„ÅÆ„Åü„ÇÅ‰∏ÄÂ∫¶ÂâäÈô§Ôºâ
            canvas.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºËøΩÂä†
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Êòü„ÅÆÂàùÊúüÂåñ
            initStars();
            
            // ÂàùÊúüË°®Á§∫
            updateHearts();
            updateSkillBar();
            
            // „Ç≤„Éº„É†„É´„Éº„ÉóÈñãÂßã
            gameLoop();
            spawnEnemies();
            dashChargeInterval = setInterval(updateDashCharges, 100);
        }
        
        // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }
        
        function handleKeyDown(e) {
            keys[e.key.toUpperCase()] = true;
            
            // „Çπ„Ç≠„É´Áô∫Âãï
            if (['Q', 'W', 'E', 'R'].includes(e.key.toUpperCase())) {
                activateSkill(e.key.toUpperCase());
            }
        }
        
        function handleKeyUp(e) {
            keys[e.key.toUpperCase()] = false;
        }
        
        // „ÉÄ„ÉÉ„Ç∑„É•„ÉÅ„É£„Éº„Ç∏ÂõûÂæ©
        function updateDashCharges() {
            Object.values(player.skills).forEach(skill => {
                if (skill && skill.id === 'dash' && skill.charges < skill.maxCharges) {
                    const now = Date.now();
                    if (now - skill.lastUsed >= skill.cooldown) {
                        skill.charges++;
                        // maxCharges„Å´ÈÅî„Åó„Å¶„ÇÇlastUsed„ÅØÊõ¥Êñ∞„Åó„Å™„ÅÑÔºàÊ¨°„ÅÆ„ÉÅ„É£„Éº„Ç∏„ÅÆ„Åü„ÇÅÔºâ
                        if (skill.charges < skill.maxCharges) {
                            skill.lastUsed = now;
                        }
                    }
                }
            });
            updateSkillBar();  // UI„ÇíÊõ¥Êñ∞
        }
        
        // „ÉÄ„ÉÉ„Ç∑„É•ÂÆüË°å
        function performDash() {
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const dashDistance = 100;
                const ratio = Math.min(dashDistance / distance, 1);
                player.x += dx * ratio;
                player.y += dy * ratio;
                
                // „ÉÄ„ÉÉ„Ç∑„É•‰∏≠„ÅØ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°Êïµ
                player.invulnerable = Math.max(player.invulnerable, 10);
                
                // „ÉÄ„ÉÉ„Ç∑„É•„Ç®„Éï„Çß„ÇØ„Éà
                createDashEffect();
            }
        }
        
        // „ÉÄ„ÉÉ„Ç∑„É•„Ç®„Éï„Çß„ÇØ„Éà
        function createDashEffect() {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    size: Math.random() * 8 + 4,
                    life: 25,
                    color: `hsl(${180 + Math.random() * 60}, 100%, 50%)`,
                    type: 'dash'
                });
            }
        }
        
        // „Éó„É¨„Ç§„É§„ÉºÊõ¥Êñ∞
        function updatePlayer() {
            // „Éû„Ç¶„ÇπËøΩÂæìÁßªÂãï
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                const baseSpeed = player.speed * (1 + player.upgrades.baseSpeed * 0.1);
                const moveX = (dx / distance) * baseSpeed;
                const moveY = (dy / distance) * baseSpeed;
                
                player.x += moveX;
                player.y += moveY;
            }
            
            // ÁîªÈù¢Â¢ÉÁïå
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            
            // ÁÑ°ÊïµÊôÇÈñì
            if (player.invulnerable > 0) player.invulnerable--;
            
            // Ëá™ÂãïÂ∞ÑÊíÉ
            let currentFireRate = player.fireRate * (1 + player.upgrades.baseFireRate * 0.1);
            
            // Rapid Fire„Çπ„Ç≠„É´„ÉÅ„Çß„ÉÉ„ÇØ
            const rapidFire = Object.values(player.skills).find(s => s && s.id === 'rapidFire');
            if (rapidFire && rapidFire.active) {
                currentFireRate *= rapidFire.fireRateMultiplier;
            }
            
            if (gameState.time % Math.floor(60 / currentFireRate) === 0) {
                shoot();
            }
        }
        
        // Â∞ÑÊíÉ
        function shoot() {
            const baseDamage = player.damage * (1 + player.upgrades.baseDamage * 0.1);
            
            // Spread Shot„ÉÅ„Çß„ÉÉ„ÇØ
            const spreadShot = Object.values(player.skills).find(s => s && s.id === 'spreadShot');
            if (spreadShot && spreadShot.active) {
                const bulletCount = spreadShot.level >= 5 ? 5 : 3;
                const angleSpread = Math.PI / 3;
                const spreadDamage = baseDamage * 1.25; // 125%„ÅÆÂ®ÅÂäõ
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = -Math.PI / 2 + (angleSpread * (i - (bulletCount - 1) / 2) / (bulletCount - 1));
                    createBullet(angle, spreadDamage);
                }
                return;
            }
            
            // ÈÄöÂ∏∏Â∞ÑÊíÉ
            createBullet(-Math.PI / 2, baseDamage);
        }
        
        function createBullet(angle, damage) {
            const ricochet = Object.values(player.skills).find(s => s && s.id === 'ricochet');
            const homing = Object.values(player.skills).find(s => s && s.id === 'homing');
            const giantShot = Object.values(player.skills).find(s => s && s.id === 'laserBeam');
            
            // Giant ShotÔºàÊóß„É¨„Éº„Ç∂„Éº„Éì„Éº„É†Ôºâ„ÅÆÂäπÊûú
            let sizeMultiplier = 1;
            let damageMultiplier = 1;
            if (giantShot && giantShot.active) {
                sizeMultiplier = giantShot.level >= 5 ? 4 : 3;
                damageMultiplier = giantShot.level >= 5 ? 3 : 2;
            }
            
            bullets.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * 10,
                vy: Math.sin(angle) * 10,
                damage: damage * damageMultiplier,
                pierce: false,
                homing: homing && homing.active,
                ricochet: ricochet && ricochet.active,
                bounces: ricochet && ricochet.active ? 3 : 0,
                size: 5 * sizeMultiplier,
                trail: [],
                isPlayerBullet: true
            });
        }
        
        // Âºæ‰∏∏Êõ¥Êñ∞
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                // „Éà„É¨„Ç§„É´Êõ¥Êñ∞
                bullet.trail.push({ x: bullet.x, y: bullet.y });
                if (bullet.trail.length > 10) bullet.trail.shift();
                
                // „Éõ„Éº„Éü„É≥„Ç∞
                if (bullet.homing && enemies.length > 0 && bullet.isPlayerBullet) {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    
                    enemies.forEach(enemy => {
                        const dist = Math.sqrt((enemy.x - bullet.x) ** 2 + (enemy.y - bullet.y) ** 2);
                        if (dist < nearestDist && dist < 200) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        const dx = nearestEnemy.x - bullet.x;
                        const dy = nearestEnemy.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        bullet.vx += (dx / dist) * 0.8;
                        bullet.vy += (dy / dist) * 0.8;
                        
                        const speed = Math.sqrt(bullet.vx ** 2 + bullet.vy ** 2);
                        bullet.vx = (bullet.vx / speed) * 12;
                        bullet.vy = (bullet.vy / speed) * 12;
                    }
                }
                
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // „É™„Ç≥„Ç∑„Çß„ÉÉ„Éà
                if (bullet.ricochet && bullet.bounces > 0 && bullet.isPlayerBullet) {
                    if (bullet.x <= 0 || bullet.x >= canvas.width) {
                        bullet.vx *= -1;
                        bullet.bounces--;
                        createRicochetEffect(bullet.x, bullet.y);
                    }
                    if (bullet.y <= 0 || bullet.y >= canvas.height) {
                        bullet.vy *= -1;
                        bullet.bounces--;
                        createRicochetEffect(bullet.x, bullet.y);
                    }
                }
                
                // ÁîªÈù¢Â§ñ„ÉÅ„Çß„ÉÉ„ÇØ
                return bullet.x > -50 && bullet.x < canvas.width + 50 && 
                       bullet.y > -50 && bullet.y < canvas.height + 50 &&
                       bullet.bounces >= 0;
            });
        }
        
        // „É™„Ç≥„Ç∑„Çß„ÉÉ„Éà„Ç®„Éï„Çß„ÇØ„Éà
        function createRicochetEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    life: 15,
                    color: '#ffff00',
                    type: 'spark'
                });
            }
        }
        
        // Êïµ„Çπ„Éù„Éº„É≥
        function spawnEnemies() {
            if (!gameState.running || gameState.deathAnimating) return;
            
            // Êïµ„ÅÆÂá∫ÁèæÊï∞ÔºàÂ¢óÂä†Áéá50%„ÄÅÊúÄÂ§ß2.5ÂÄçÔºâ
            let baseEnemyCount = 3;
            let enemyCount = Math.min(baseEnemyCount + Math.floor((gameState.level - 1) * 0.5), baseEnemyCount * 2.5);
            enemyCount = Math.floor(enemyCount);
            
            // „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÊôÇ„ÅØÊïµ„ÅÆÂá∫ÁèæÈáè„Çí50%„Å´
            if (gameState.enemySpawnReduction) {
                enemyCount = Math.floor(enemyCount * 0.5);
            }
            
            // Èùí„ÅÑÊïµ„ÅÆÁâπÂà•„Å™„Çπ„Éù„Éº„É≥Âá¶ÁêÜ
            if (gameState.level === 10 && blueEnemyCount === 0 && !gameState.firstBlueSpawned) {
                gameState.firstBlueSpawned = true;
                gameState.lastBlueSpawnTime = Date.now();
                spawnBlueEnemy();
            } else if (gameState.level >= 10 && blueEnemyCount < 3) {
                const now = Date.now();
                if (now - gameState.lastBlueSpawnTime >= 30000) { // 30Áßí
                    gameState.lastBlueSpawnTime = now;
                    spawnBlueEnemy();
                }
            }
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    if (!gameState.running || gameState.deathAnimating) return;
                    
                    const enemyType = Math.random();
                    // ‰ΩìÂäõ„ÅÆÂ¢óÂä†Áéá„Çí15%„Å´„ÄÅÊúÄÂ§ß300%Ôºà3ÂÄçÔºâ
                    const levelBonus = Math.min((gameState.level - 1) * 0.15, 2.0);
                    
                    const isZigzag = gameState.level >= 10 && Math.random() < 0.3;
                    const isRed = Math.random() < 0.5;
                    
                    const baseHp = isRed ? 15 : 40;
                    const hp = Math.floor(baseHp * (1 + levelBonus));
                    
                    enemies.push({
                        x: Math.random() * (canvas.width - 60) + 30,
                        y: -30,
                        vx: (Math.random() - 0.5) * (isRed ? 3 : 1.5),
                        vy: (Math.random() * 2 + 1) * (isRed ? 1.5 : 0.7),
                        hp: hp,
                        maxHp: hp,
                        size: 15,
                        color: isZigzag ? '#ffff33' : (isRed ? '#ff3333' : '#ff9933'),
                        value: 10 + gameState.level * 5,
                        type: isZigzag ? 'zigzag' : 'normal',
                        zigzagTime: 0
                    });
                }, i * 200);
            }
            
            setTimeout(() => spawnEnemies(), 2000 - Math.min(gameState.level * 50, 1000));
        }
        
        // Èùí„ÅÑÊïµÂ∞ÇÁî®„ÅÆ„Çπ„Éù„Éº„É≥Èñ¢Êï∞
        function spawnBlueEnemy() {
            if (blueEnemyCount >= 3) return;
            
            const levelBonus = Math.min((gameState.level - 1) * 0.15, 2.0);
            const hp = Math.floor(120 * (1 + levelBonus)); // Âü∫Êú¨HP 120ÔºàÈªÑËâ≤„ÅÆ3ÂÄçÔºâ
            
            // ÁîªÈù¢Á´Ø„ÅÆ4„Å§„ÅÆ‰ΩçÁΩÆ„Åã„Çâ„É©„É≥„ÉÄ„É†„Å´ÈÅ∏Êäû
            const positions = [
                { x: 50, y: 50, vx: 1, vy: 0, direction: 'right' },
                { x: canvas.width - 50, y: 50, vx: 0, vy: 1, direction: 'down' },
                { x: canvas.width - 50, y: canvas.height - 100, vx: -1, vy: 0, direction: 'left' },
                { x: 50, y: canvas.height - 100, vx: 0, vy: -1, direction: 'up' }
            ];
            
            const startPos = positions[Math.floor(Math.random() * positions.length)];
            
            enemies.push({
                x: startPos.x,
                y: startPos.y,
                vx: startPos.vx,
                vy: startPos.vy,
                direction: startPos.direction,
                hp: hp,
                maxHp: hp,
                size: 15 * 1.5,
                color: '#3333ff',
                value: 50 + gameState.level * 10,
                type: 'blue',
                shootCooldown: 0
            });
            blueEnemyCount++;
        }
        
        // ÊïµÊõ¥Êñ∞
        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                // HP„Åå0‰ª•‰∏ã„ÅÆÊïµ„ÅØÂç≥Â∫ß„Å´ÂâäÈô§
                if (enemy.hp <= 0) {
                    if (enemy.type === 'blue') blueEnemyCount--;
                    return false;
                }
                
                if (enemy.type === 'blue') {
                    // Èùí„ÅÑÊïµ„ÅÆÂãï„ÅçÔºàÁîªÈù¢Á´Ø„ÇíÂë®ÂõûÔºâ
                    const speed = 1; // ÈÄüÂ∫¶„Çí50%„Å´
                    const margin = 50;
                    
                    enemy.x += enemy.vx * speed;
                    enemy.y += enemy.vy * speed;
                    
                    // „Ç≥„Éº„Éä„Éº„Å´Âà∞ÈÅî„Åó„Åü„ÇâÊñπÂêëËª¢Êèõ
                    if (enemy.direction === 'right' && enemy.x >= canvas.width - margin) {
                        enemy.x = canvas.width - margin;
                        enemy.vx = 0;
                        enemy.vy = 1;
                        enemy.direction = 'down';
                    } else if (enemy.direction === 'down' && enemy.y >= canvas.height - 100) {
                        enemy.y = canvas.height - 100;
                        enemy.vx = -1;
                        enemy.vy = 0;
                        enemy.direction = 'left';
                    } else if (enemy.direction === 'left' && enemy.x <= margin) {
                        enemy.x = margin;
                        enemy.vx = 0;
                        enemy.vy = -1;
                        enemy.direction = 'up';
                    } else if (enemy.direction === 'up' && enemy.y <= margin) {
                        enemy.y = margin;
                        enemy.vx = 1;
                        enemy.vy = 0;
                        enemy.direction = 'right';
                    }
                    
                    // 1Áßí„Åî„Å®„Å´Âºæ„ÇíÊíÉ„Å§
                    enemy.shootCooldown++;
                    if (enemy.shootCooldown >= 60) {
                        enemy.shootCooldown = 0;
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        bullets.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 5,
                            vy: Math.sin(angle) * 5,
                            damage: 1,
                            size: 8,
                            color: '#3333ff',
                            isEnemyBullet: true,
                            trail: []
                        });
                    }
                } else if (enemy.type === 'zigzag') {
                    // „Ç∏„Ç∞„Ç∂„Ç∞ÁßªÂãï
                    enemy.zigzagTime += 0.1;
                    enemy.x += Math.sin(enemy.zigzagTime) * 3;
                    enemy.y += enemy.vy;
                } else {
                    // ÈÄöÂ∏∏„ÅÆÊïµ
                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;
                    
                    // ÁîªÈù¢Á´Ø„ÅßÂèçÂ∞Ñ
                    if (enemy.x < enemy.size || enemy.x > canvas.width - enemy.size) {
                        enemy.vx *= -1;
                    }
                }
                
                // ÁîªÈù¢Â§ñ„ÉÅ„Çß„ÉÉ„ÇØÔºàÈùí„ÅÑÊïµ„ÅØÁîªÈù¢Â§ñ„Å´Âá∫„Å™„ÅÑÔºâ
                if (enemy.type !== 'blue' && enemy.y > canvas.height + 30) {
                    return false;
                }
                
                return true;
            });
        }
        
        // Ë°ùÁ™ÅÂà§ÂÆö
        function checkCollisions() {
            // „Éê„É™„Ç¢„ÉÅ„Çß„ÉÉ„ÇØ
            const barrier = Object.values(player.skills).find(s => s && s.id === 'barrier');
            const hasBarrier = barrier && barrier.active;
            
            // ÂâäÈô§„Åô„ÇãÊïµ„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰øùÂ≠ò
            const enemiesToRemove = new Set();
            
            // Âºæ‰∏∏„Å®Êïµ/„Éó„É¨„Ç§„É§„Éº
            bullets = bullets.filter(bullet => {
                // „Éó„É¨„Ç§„É§„Éº„ÅÆÂºæ„Å®Êïµ„ÅÆË°ùÁ™Å
                if (bullet.isPlayerBullet) {
                    for (let i = 0; i < enemies.length; i++) {
                        if (enemiesToRemove.has(i)) continue;
                        
                        const enemy = enemies[i];
                        const dist = Math.sqrt((bullet.x - enemy.x) ** 2 + (bullet.y - enemy.y) ** 2);
                        
                        if (dist < bullet.size + enemy.size) {
                            enemy.hp -= bullet.damage;
                            
                            // „Éí„ÉÉ„Éà„Ç®„Éï„Çß„ÇØ„Éà
                            createHitEffect(enemy.x, enemy.y);
                            
                            if (enemy.hp <= 0) {
                                // ÊïµÊíÉÁ†¥
                                gameState.score += enemy.value;
                                createExplosion(enemy.x, enemy.y);
                                dropExp(enemy.x, enemy.y, enemy.value);
                                if (enemy.type === 'blue') blueEnemyCount--;
                                enemiesToRemove.add(i);
                            }
                            
                            if (!bullet.pierce && !bullet.isLaser) {
                                return false;
                            }
                        }
                    }
                } 
                // Êïµ„ÅÆÂºæ
                else if (bullet.isEnemyBullet) {
                    // „Éó„É¨„Ç§„É§„Éº„ÅÆÂºæ„ÅßÁ†¥Â£äÂèØËÉΩ
                    for (let playerBullet of bullets) {
                        if (playerBullet.isPlayerBullet) {
                            const dist = Math.sqrt((bullet.x - playerBullet.x) ** 2 + (bullet.y - playerBullet.y) ** 2);
                            if (dist < bullet.size + playerBullet.size) {
                                createHitEffect(bullet.x, bullet.y);
                                return false;
                            }
                        }
                    }
                    
                    // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆË°ùÁ™Å
                    const invincible = Object.values(player.skills).find(s => s && s.id === 'invincible');
                    const isInvincible = (invincible && invincible.active) || player.invulnerable > 0;
                    
                    if (!isInvincible) {
                        const dist = Math.sqrt((bullet.x - player.x) ** 2 + (bullet.y - player.y) ** 2);
                        if (dist < bullet.size + player.size) {
                            takeDamage();
                            createHitEffect(player.x, player.y);
                            return false;
                        }
                    }
                }
                
                return true;
            });
            
            // „Éû„Éº„ÇØ„Åï„Çå„ÅüÊïµ„ÇíÂâäÈô§
            enemies = enemies.filter((enemy, index) => !enemiesToRemove.has(index));
            
            // „Éó„É¨„Ç§„É§„Éº„Å®Êïµ
            const invincible = Object.values(player.skills).find(s => s && s.id === 'invincible');
            const isInvincible = (invincible && invincible.active) || player.invulnerable > 0;
            
            if (!isInvincible) {
                enemies = enemies.filter(enemy => {
                    const dist = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                    
                    // „Éê„É™„Ç¢„ÉÅ„Çß„ÉÉ„ÇØ
                    if (hasBarrier && dist < barrier.radius) {
                        // „Éê„É™„Ç¢„ÅåÊïµ„ÇíÊäº„ÅóËøî„Åô
                        const angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        enemy.x += Math.cos(angle) * 5;
                        enemy.y += Math.sin(angle) * 5;
                        createHitEffect(enemy.x, enemy.y);
                        enemy.hp -= player.damage * 0.5;
                        
                        if (enemy.hp <= 0) {
                            gameState.score += enemy.value;
                            createExplosion(enemy.x, enemy.y);
                            dropExp(enemy.x, enemy.y, enemy.value);
                            if (enemy.type === 'blue') blueEnemyCount--;
                            return false;
                        }
                    } else if (dist < player.size + enemy.size) {
                        takeDamage();
                        createHitEffect(player.x, player.y);
                    }
                    
                    return true;
                });
            }
            
            // ÁµåÈ®ìÂÄ§„Ç™„Éº„ÉñÂõûÂèé
            expOrbs = expOrbs.filter(orb => {
                const dist = Math.sqrt((player.x - orb.x) ** 2 + (player.y - orb.y) ** 2);
                const magnetRange = 50;
                
                if (dist < magnetRange) {
                    // Âºï„ÅçÂØÑ„Åõ
                    const dx = player.x - orb.x;
                    const dy = player.y - orb.y;
                    orb.x += dx * 0.2;
                    orb.y += dy * 0.2;
                    
                    if (dist < player.size + orb.size) {
                        gameState.exp += orb.value;
                        checkLevelUp();
                        return false;
                    }
                }
                
                orb.life--;
                return orb.life > 0;
            });
        }
        
        // „ÉÄ„É°„Éº„Ç∏Âá¶ÁêÜ
        function takeDamage() {
            player.lives--;
            player.invulnerable = 60; // 60„Éï„É¨„Éº„É† = 1ÁßíÔºà60FPSÊÉ≥ÂÆöÔºâ
            updateHearts();
            
            if (player.lives <= 0) {
                gameOver();
            }
        }
        
        // Ê≠ª‰∫°ÊºîÂá∫
        function createDeathAnimation() {
            gameState.deathAnimating = true;
            
            // „Éó„É¨„Ç§„É§„ÉºÁàÜÁô∫
            for (let i = 0; i < 50; i++) {
                const angle = (Math.PI * 2 * i) / 50;
                const speed = Math.random() * 15 + 5;
                
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 10 + 5,
                    life: 60,
                    color: '#00ff00',
                    type: 'death'
                });
            }
            
            // 1ÁßíÂæå„Å´„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁîªÈù¢
            setTimeout(() => {
                document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
                document.getElementById('finalLevel').textContent = gameState.level;
                
                const minutes = Math.floor(gameState.time / 3600);
                const seconds = Math.floor((gameState.time % 3600) / 60);
                document.getElementById('finalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('gameOverModal').style.display = 'block';
            }, 1000);
        }
        
        // ÁµåÈ®ìÂÄ§„Éâ„É≠„ÉÉ„Éó
        function dropExp(x, y, value) {
            const orbCount = Math.min(Math.ceil(value / 20), 5);
            
            for (let i = 0; i < orbCount; i++) {
                expOrbs.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    size: 6,
                    value: Math.floor(value / orbCount),
                    life: 400,
                    color: '#00ff00',
                    glow: 0
                });
            }
        }
        
        // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØ
        function checkLevelUp() {
            while (gameState.exp >= gameState.expNeeded) {
                gameState.exp -= gameState.expNeeded;
                gameState.level++;
                gameState.expNeeded = Math.floor(100 * Math.pow(1.2, gameState.level - 1));
                
                // „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÊôÇ„Å´Êïµ„ÅÆÂá∫Áèæ„Çí‰∏ÄÊôÇÁöÑ„Å´Ê∏õ„Çâ„Åô
                gameState.enemySpawnReduction = true;
                setTimeout(() => {
                    gameState.enemySpawnReduction = false;
                }, 3000);
                
                // „É¨„Éô„É´20„ÄÅ30„Åß„Ç¢„É´„ÉÜ„Ç£„É°„ÉÉ„ÉàËá™ÂãïÂº∑Âåñ
                if ((gameState.level === 20 || gameState.level === 30) && player.skills.R) {
                    player.skills.R.level = gameState.level;
                    updateSkillLevels(player.skills.R);
                }
                
                showLevelUpModal();
            }
            
            updateUI();
        }
        
        // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„É¢„Éº„ÉÄ„É´Ë°®Á§∫
        function showLevelUpModal() {
            gameState.paused = true;
            
            // „Çπ„Ç≠„É´„Çø„Ç§„Éû„Éº„Çí‰∏ÄÊôÇÂÅúÊ≠¢
            const pausedAt = Date.now();
            Object.values(player.skills).forEach(skill => {
                if (skill && skill.active && skill.duration) {
                    skill.pausedTime = pausedAt - skill.activatedAt;
                }
            });
            
            const modal = document.getElementById('levelUpModal');
            const optionsDiv = document.getElementById('upgradeOptions');
            optionsDiv.innerHTML = '';
            
            let options = [];
            
            // „É¨„Éô„É´10„Åß„Ç¢„É´„ÉÜ„Ç£„É°„ÉÉ„Éà„Çπ„Ç≠„É´ÈÅ∏Êäû
            if (gameState.level === 10) {
                document.getElementById('levelUpMessage').textContent = 'ULTIMATE SKILL UNLOCKED! Choose your ultimate:';
                options = [
                    {...skills.invincible},
                    {...skills.ricochet},
                    {...skills.homing}
                ];
            } else {
                document.getElementById('levelUpMessage').textContent = 'Choose your upgrade:';
                
                // Âü∫Êú¨„Çπ„Ç≠„É´Ôºà3„Å§„Åæ„ÅßÔºâ
                if (player.basicSkillCount < 3) {
                    const availableBasicSkills = Object.values(skills).filter(s => 
                        s.type === 'basic' && 
                        !Object.values(player.skills).find(ps => ps && ps.id === s.id)
                    );
                    
                    if (availableBasicSkills.length > 0) {
                        const selected = availableBasicSkills[Math.floor(Math.random() * availableBasicSkills.length)];
                        options.push({...selected});
                    }
                }
                
                // Êó¢Â≠ò„Çπ„Ç≠„É´„ÅÆ„É¨„Éô„É´„Ç¢„ÉÉ„Éó
                Object.entries(player.skills).forEach(([key, skill]) => {
                    if (skill && skill !== 'empty' && skill.level < skill.maxLevel) {
                        options.push({...skill, isLevelUp: true, key: key});
                    }
                });
                
                // Âü∫Á§é„Çπ„ÉÜ„Éº„Çø„Çπ
                if (player.upgrades.baseSpeed < 5) {
                    options.push({
                        name: 'Speed Boost',
                        description: `Increase base speed by 10% (Lv ${player.upgrades.baseSpeed + 1}/5)`,
                        icon: 'üëü',
                        type: 'stat',
                        stat: 'baseSpeed'
                    });
                }
                
                if (player.upgrades.baseDamage < 5) {
                    options.push({
                        name: 'Damage Boost',
                        description: `Increase base damage by 10% (Lv ${player.upgrades.baseDamage + 1}/5)`,
                        icon: '‚öîÔ∏è',
                        type: 'stat',
                        stat: 'baseDamage'
                    });
                }
                
                if (player.upgrades.baseFireRate < 5) {
                    options.push({
                        name: 'Fire Rate Boost',
                        description: `Increase base fire rate by 10% (Lv ${player.upgrades.baseFireRate + 1}/5)`,
                        icon: 'üî´',
                        type: 'stat',
                        stat: 'baseFireRate'
                    });
                }
                
                // „Éí„Éº„É´Ôºà„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„Åø„ÄÅÊúÄÂ§ß5ÂõûÔºâ
                if (player.lives < player.maxLives && player.upgrades.healCount < 5) {
                    options.push({
                        name: 'Heal',
                        description: 'Restore 1 life',
                        icon: '‚ù§Ô∏è',
                        type: 'heal'
                    });
                }
                
                // „É©„É≥„ÉÄ„É†„Å´3„Å§ÈÅ∏Êäû
                options = options.sort(() => Math.random() - 0.5).slice(0, 3);
            }
            
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'upgradeOption';
                if (option.type === 'ultimate') {
                    optionDiv.className += ' ultimate';
                }
                
                let description = option.description;
                if (option.isLevelUp) {
                    description = `Level ${option.level + 1}: ${option.description}`;
                    if (option.level === 1 || option.level === 3) {
                        description += ' (Duration +20%)';
                    } else if (option.level === 2 || option.level === 5) {
                        description += ' (Cooldown -20%)';
                    } else if (option.level === 4 && option.levelBonus && option.levelBonus[5]) {
                        description += ` (Next: ${option.levelBonus[5]})`;
                    }
                }
                
                optionDiv.innerHTML = `
                    <h3>${option.icon} ${option.name}</h3>
                    <p>${description}</p>
                `;
                
                optionDiv.onclick = () => {
                    if (option.type === 'stat') {
                        player.upgrades[option.stat]++;
                    } else if (option.type === 'heal') {
                        player.lives = Math.min(player.lives + 1, player.maxLives);
                        player.upgrades.healCount++;
                        updateHearts();
                    } else if (option.isLevelUp) {
                        const playerSkill = Object.values(player.skills).find(s => s && s.id === option.id);
                        if (playerSkill) {
                            updateSkillLevels(playerSkill);
                        }
                    } else {
                        // Êñ∞„Åó„ÅÑ„Çπ„Ç≠„É´Áç≤Âæó
                        const newSkill = {
                            ...option,
                            level: 1,
                            lastUsed: 0,
                            active: false,
                            activatedAt: 0
                        };
                        
                        if (option.type === 'ultimate') {
                            player.skills.R = newSkill;
                        } else {
                            // Âü∫Êú¨„Çπ„Ç≠„É´„ÇíÁ©∫„ÅÑ„Å¶„ÅÑ„Çã„Çπ„É≠„ÉÉ„Éà„Å´ÈÖçÁΩÆ
                            for (let key of ['Q', 'W', 'E']) {
                                if (!player.skills[key] || player.skills[key] === 'empty') {
                                    player.skills[key] = newSkill;
                                    player.basicSkillCount++;
                                    break;
                                }
                            }
                        }
                    }
                    
                    modal.style.display = 'none';
                    gameState.paused = false;
                    
                    // „Çπ„Ç≠„É´„Çø„Ç§„Éû„ÉºÂÜçÈñã
                    const resumedAt = Date.now();
                    Object.values(player.skills).forEach(skill => {
                        if (skill && skill.active && skill.pausedTime !== undefined) {
                            skill.activatedAt = resumedAt - skill.pausedTime;
                            delete skill.pausedTime;
                        }
                    });
                    
                    updateSkillBar();
                };
                
                optionsDiv.appendChild(optionDiv);
            });
            
            modal.style.display = 'block';
        }
        
        // „Ç®„Éï„Çß„ÇØ„Éà‰ΩúÊàê
        function createHitEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: Math.random() * 3 + 1,
                    life: 10,
                    color: '#ffff00',
                    type: 'hit'
                });
            }
        }
        
        function createExplosion(x, y) {
            // ÈÄöÂ∏∏„ÅÆÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÔºàË¶ñË¶öÁöÑ„ÅÆ„ÅøÔºâ
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const speed = Math.random() * 5 + 2;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 5 + 3,
                    life: 30,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`,
                    type: 'explosion'
                });
            }
        }
        
        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êõ¥Êñ∞
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.type === 'explosion' || particle.type === 'death') {
                    particle.size *= 0.95;
                    particle.vy += 0.1;
                } else if (particle.type === 'dash') {
                    particle.size *= 0.9;
                }
                
                return particle.life > 0;
            });
        }
        
        // ÊèèÁîª
        function draw() {
            // ËÉåÊôØ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Êòü„ÅÆÊèèÁîª
            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                ctx.globalAlpha = star.brightness;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // ÁµåÈ®ìÂÄ§„Ç™„Éº„Éñ
            expOrbs.forEach(orb => {
                orb.glow = (orb.glow + 0.1) % (Math.PI * 2);
                const glowSize = orb.size + Math.sin(orb.glow) * 2;
                
                ctx.fillStyle = orb.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = orb.color;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ÂÜÖÈÉ®„ÅÆÂÖâ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, glowSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 40;
                
                if (particle.type === 'spark') {
                    // ÁÅ´Ëä±„Ç®„Éï„Çß„ÇØ„Éà
                    ctx.strokeStyle = particle.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.x - particle.vx, particle.y - particle.vy);
                    ctx.stroke();
                } else {
                    ctx.fillRect(
                        particle.x - particle.size / 2,
                        particle.y - particle.size / 2,
                        particle.size,
                        particle.size
                    );
                }
            });
            ctx.globalAlpha = 1;
            
            // Âºæ‰∏∏
            bullets.forEach(bullet => {
                if (bullet.isEnemyBullet) {
                    ctx.fillStyle = bullet.color || '#ff00ff';
                } else {
                    ctx.fillStyle = bullet.homing ? '#ff00ff' : 
                                   bullet.pierce ? '#00ffff' : '#00ffff';
                }
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.fillStyle;
                
                // „Éà„É¨„Ç§„É´
                if (bullet.trail && bullet.trail.length > 1) {
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = bullet.size * 0.5;
                    ctx.beginPath();
                    bullet.trail.forEach((point, index) => {
                        ctx.globalAlpha = index / bullet.trail.length * 0.5;
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Êïµ
            enemies.forEach(enemy => {
                // HP„Åå0‰ª•‰∏ã„ÅÆÊïµ„ÅØÊèèÁîª„Åó„Å™„ÅÑ
                if (enemy.hp <= 0) return;
                
                ctx.fillStyle = enemy.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = enemy.color;
                
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                if (enemy.type === 'blue') {
                    // „Å≤„ÅóÂΩ¢
                    ctx.beginPath();
                    ctx.moveTo(0, -enemy.size);
                    ctx.lineTo(enemy.size, 0);
                    ctx.lineTo(0, enemy.size);
                    ctx.lineTo(-enemy.size, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // ÂÜÜÂΩ¢
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // HP„Éê„Éº
                if (enemy.hp < enemy.maxHp && enemy.hp > 0) {
                    const barWidth = enemy.size * 3;
                    const barHeight = 4;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth, barHeight);
                    
                    ctx.fillStyle = '#ff0000';
                    const hpRatio = Math.max(0, enemy.hp / enemy.maxHp); // Ë≤†„ÅÆÂÄ§„ÇíÈò≤„Åê
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth * hpRatio, barHeight);
                }
            });
            
            // „Éó„É¨„Ç§„É§„ÉºÔºàÊ≠ª‰∫°ÊºîÂá∫‰∏≠„ÅØÊèèÁîª„Åó„Å™„ÅÑÔºâ
            if (!gameState.deathAnimating) {
                ctx.save();
                ctx.translate(player.x, player.y);
                
                // ÁÑ°ÊïµÊôÇ„ÅÆÁÇπÊªÖ
                if (player.invulnerable > 0 && Math.floor(player.invulnerable / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.3;
                }
                
                // „Éê„É™„Ç¢Ë°®Á§∫
                const barrier = Object.values(player.skills).find(s => s && s.id === 'barrier');
                if (barrier && barrier.active) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, barrier.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // „Éê„É™„Ç¢„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                    if (gameState.time % 5 === 0) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: player.x + Math.cos(angle) * barrier.radius,
                            y: player.y + Math.sin(angle) * barrier.radius,
                            vx: Math.cos(angle) * 0.5,
                            vy: Math.sin(angle) * 0.5,
                            size: 3,
                            life: 20,
                            color: '#00ffff',
                            type: 'barrier'
                        });
                    }
                }
                
                // Invincible„Ç®„Éï„Çß„ÇØ„Éà
                const invincible = Object.values(player.skills).find(s => s && s.id === 'invincible');
                if (invincible && invincible.active) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.lineDashOffset = gameState.time * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, player.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Êú¨‰Ωì
                ctx.fillStyle = '#00ff00';
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#00ff00';
                
                ctx.beginPath();
                ctx.moveTo(0, -player.size);
                ctx.lineTo(-player.size * 0.7, player.size * 0.7);
                ctx.lineTo(0, player.size * 0.4);
                ctx.lineTo(player.size * 0.7, player.size * 0.7);
                ctx.closePath();
                ctx.fill();
                
                // „Ç≥„ÉÉ„ÇØ„Éî„ÉÉ„Éà
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, player.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // „Éç„Ç™„É≥È¢®„ÅÆÊû†„ÇíÊèèÁîª
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            
            // Â§ñÂÅ¥„ÅÆÊû†
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            
            // ÂÜÖÂÅ¥„ÅÆÊû†Ôºà„Çà„ÇäÊòé„Çã„ÅèÔºâ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'white';
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            // Ëßí„ÅÆË£ÖÈ£æ
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            
            // Â∑¶‰∏ä
            ctx.beginPath();
            ctx.moveTo(5, 25);
            ctx.lineTo(5, 5);
            ctx.lineTo(25, 5);
            ctx.stroke();
            
            // Âè≥‰∏ä
            ctx.beginPath();
            ctx.moveTo(canvas.width - 25, 5);
            ctx.lineTo(canvas.width - 5, 5);
            ctx.lineTo(canvas.width - 5, 25);
            ctx.stroke();
            
            // Â∑¶‰∏ã
            ctx.beginPath();
            ctx.moveTo(5, canvas.height - 25);
            ctx.lineTo(5, canvas.height - 5);
            ctx.lineTo(25, canvas.height - 5);
            ctx.stroke();
            
            // Âè≥‰∏ã
            ctx.beginPath();
            ctx.moveTo(canvas.width - 25, canvas.height - 5);
            ctx.lineTo(canvas.width - 5, canvas.height - 5);
            ctx.lineTo(canvas.width - 5, canvas.height - 25);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }
        
        // UIÊõ¥Êñ∞
        function updateUI() {
            document.getElementById('score').textContent = gameState.score.toLocaleString();
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('exp').textContent = gameState.exp;
            document.getElementById('expNeeded').textContent = gameState.expNeeded;
            
            const minutes = Math.floor(gameState.time / 3600);
            const seconds = Math.floor((gameState.time % 3600) / 60);
            document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
        function gameOver() {
            gameState.running = false;
            createDeathAnimation();
        }
        
        // „É™„Çª„ÉÉ„Éà
        function resetGame() {
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Å®„Ç§„É≥„Çø„Éº„Éê„É´„Çí„ÇØ„É™„Ç¢
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (dashChargeInterval) {
                clearInterval(dashChargeInterval);
                dashChargeInterval = null;
            }
            
            gameState = {
                running: false,
                paused: false,
                score: 0,
                level: 1,
                exp: 0,
                expNeeded: 100,
                time: 0,
                deathAnimating: false,
                enemySpawnReduction: false,
                firstBlueSpawned: false,
                lastBlueSpawnTime: 0
            };
            
            player = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                size: 20,
                lives: 5,
                maxLives: 5,
                invulnerable: 0,
                speed: 5,
                damage: 10,
                fireRate: 2.5,
                upgrades: {
                    baseSpeed: 0,
                    baseDamage: 0,
                    baseFireRate: 0,
                    healCount: 0
                },
                skills: {
                    Q: null,
                    W: null,
                    E: null,
                    R: null
                },
                basicSkillCount: 0
            };
            
            // „Çπ„Ç≠„É´„É™„Çª„ÉÉ„Éà
            Object.values(skills).forEach(skill => {
                skill.level = skill.type === 'ultimate' ? 10 : 0;
                skill.active = false;
                skill.lastUsed = 0;
                skill.activatedAt = 0;
                if (skill.id === 'dash') {
                    skill.charges = 1;
                    skill.maxCharges = 1;
                }
                if (skill.id === 'rapidFire') {
                    skill.fireRateMultiplier = 2;
                }
                if (skill.id === 'barrier') {
                    skill.radius = 50;
                }
                // ÂêÑ„Çπ„Ç≠„É´„ÅÆ duration „Å® cooldown „Çí„É™„Çª„ÉÉ„Éà
                if (skill.baseDuration) {
                    skill.duration = skill.baseDuration;
                }
                if (skill.baseCooldown) {
                    skill.cooldown = skill.baseCooldown;
                }
            });
            
            bullets = [];
            enemies = [];
            particles = [];
            expOrbs = [];
            blueEnemyCount = 0;
            
            updateUI();
            updateHearts();
            updateSkillBar();
        }
        
        // „Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            if (gameState.running && !gameState.paused) {
                gameState.time++;
                
                updatePlayer();
                updateBullets();
                updateEnemies();
                updateParticles();
                updateStars();
                checkCollisions();
                updateUI();
                updateSkillBar();
            }
            
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // ÂàùÊúüÁîªÈù¢Ë°®Á§∫
        updateHearts();
    </script>
</body>
</html>