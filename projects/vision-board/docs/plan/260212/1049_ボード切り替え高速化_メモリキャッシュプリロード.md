# ボード切り替え高速化 — メモリキャッシュによるプリロード

## Context
ボード切り替え時、AsyncStorage読み込み（50-100ms）の間に前のボードが表示され続ける。原因は`useNodes`/`useRoutines`のuseEffectがasyncのため、boardId変更→AsyncStorage読み込み完了の間に古い`nodes`ステートが残ること。

**解決策**: モジュールレベルの同期メモリキャッシュ（Map）を導入。アプリ起動時に現在のボードを優先ロードした後、`InteractionManager.runAfterInteractions()`で他の全ボードのデータをバックグラウンドでプリロード。切り替え時はMapから同期的に即座にスワップ。

---

## 修正ファイル一覧

| # | ファイル | 変更内容 |
|---|---------|---------|
| 1 | `hooks/useNodes.ts` | メモリキャッシュMap + `preloadBoardNodes()` + 同期スワップ |
| 2 | `hooks/useRoutines.ts` | メモリキャッシュMap + `preloadBoardRoutines()` + 同期スワップ |
| 3 | `components/canvas/BoardCanvas.tsx` | viewportメモリキャッシュ + `preloadBoardViewports()` + 同期リストア |
| 4 | `app/(main)/_layout.tsx` | 起動時プリロードトリガー（InteractionManager使用） |

---

## Step 1: useNodes.ts — ノードのメモリキャッシュ

### 1a. モジュールレベルにMap + preload関数（cacheKey定義の後、line 29付近）
```ts
const nodesMemoryCache = new Map<string, Node[]>();

export async function preloadBoardNodes(boardIds: string[]): Promise<void> {
  const toLoad = boardIds.filter((id) => !nodesMemoryCache.has(id));
  if (toLoad.length === 0) return;
  await Promise.all(toLoad.map(async (id) => {
    try {
      const cached = await AsyncStorage.getItem(cacheKey(id));
      if (cached) nodesMemoryCache.set(id, JSON.parse(cached));
    } catch {}
  }));
}
```

### 1b. `saveToCache` にメモリキャッシュ同期更新を追加（line 41）
先頭に `nodesMemoryCache.set(boardId, data);` を追加。

### 1c. `loadNodes` でメモリキャッシュを最優先チェック（line 103付近）
versionAtStart取得直後、AsyncStorage読み込みの前に:
```ts
const memoryCached = nodesMemoryCache.get(currentBoardId);
if (memoryCached && stateVersionRef.current === versionAtStart) {
  setNodes(memoryCached);
  setLoading(false);
}
```
メモリキャッシュミス時のみ従来のAsyncStorage読み込みへフォールバック。
AsyncStorage読み込み成功時はメモリキャッシュにも書き込み。

### 1d. 初期loadのuseEffect（line 257）に同期スワップを追加
boardId変更時、loadNodes()の前に:
- メモリキャッシュヒット → `setNodes(cached)` + `setLoading(false)` で即表示
- ミス → `setNodes([])` で旧ボードを即座にクリア（スピナー表示）

---

## Step 2: useRoutines.ts — ルーティンのメモリキャッシュ

Step 1と同パターン。

### 2a. モジュールレベルにMap + preload関数（line 14付近）
`routinesMemoryCache` + `routineNodesMemoryCache` の2つのMapと`preloadBoardRoutines()`をexport。

### 2b. save関数にメモリキャッシュ同期更新
`saveRoutinesToCache` / `saveRoutineNodesToCache` の先頭でMap更新。
※ これらはuseCallback内でcacheKeyをクロージャ参照するため、boardIdを直接使えない。
→ `loadRoutines`内のサーバーfetch成功後にMapへの書き込みを追加する方式。

### 2c. `loadRoutines`でメモリキャッシュを最優先チェック

### 2d. 初期loadのuseEffect（line 287）に同期スワップ

---

## Step 3: BoardCanvas.tsx — ビューポートのメモリキャッシュ

### 3a. モジュールレベルにMap + preload関数（line 58付近）
`viewportMemoryCache` Mapと`preloadBoardViewports()`をexport。

### 3b. `saveViewport`にメモリキャッシュ同期更新
先頭に `viewportMemoryCache.set(boardId, state);` を追加。

### 3c. viewport復元useEffect（line 210）で同期リストア
メモリキャッシュヒット → SharedValueを同期的に設定して`return`（async不要）。
ミス → 従来通りAsyncStorageから非同期読み込み。

---

## Step 4: _layout.tsx — 起動時プリロードトリガー

`MainLayoutContent`内で、現在のボード表示完了後にバックグラウンドでプリロード。

```ts
import { InteractionManager } from 'react-native';
import { preloadBoardNodes } from '../../hooks/useNodes';
import { preloadBoardRoutines } from '../../hooks/useRoutines';
import { preloadBoardViewports } from '../../components/canvas/BoardCanvas';

// MainLayoutContent内:
useEffect(() => {
  if (boards.length > 0 && selectedBoardId) {
    // 現在のボードのレンダリング完了後にバックグラウンドでプリロード
    const task = InteractionManager.runAfterInteractions(() => {
      const otherIds = boards.map(b => b.id).filter(id => id !== selectedBoardId);
      if (otherIds.length === 0) return;
      preloadBoardNodes(otherIds);
      preloadBoardRoutines(otherIds);
      preloadBoardViewports(otherIds);
    });
    return () => task.cancel();
  }
}, [boards, selectedBoardId]);
```

**タイミング**:
1. アプリ起動 → 現在のボード(selectedBoardId)のノード・ルーティン・viewportが通常通りロード
2. 現在のボードのレンダリング＆アニメーション完了後（`runAfterInteractions`）
3. 他のボードのデータをAsyncStorageからメモリキャッシュにプリロード
4. ユーザーがボードを切り替えた時点ではメモリキャッシュ済み → 即座にスワップ

---

## 安全性

- **楽観的更新との整合**: `stateVersionRef`ガードは変更なし
- **メモリ使用量**: 20ボード × 50ノード × 200B ≈ 200KB（無視できる）
- **新規ボード**: メモリキャッシュミス → `setNodes([])` → 従来フロー
- **dataEventsとの整合**: `saveToCache`がメモリキャッシュも更新
- **プリロード失敗**: 個別try/catchで無視、通常のAsyncStorageフローにフォールバック

## 検証方法
1. 3つ以上のボード間を切り替え → スピナーなし、旧ボードのフラッシュなし
2. ノード追加/削除 → ボード切り替え → 戻る → 変更が保持されていること
3. アプリ起動直後のボード切り替え → プリロード完了前でもAsyncStorageフォールバックで動作
