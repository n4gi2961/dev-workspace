# RoutineWeeklyTable — 統一順序モデル＋カラムリサイズ実装計画

## Context
現在のスタック管理は「未所属ルーティン→スタック」の固定順で自由度が低い。スタックへの移動は境界線経由、スタック名変更はAlertポップアップ、スタック自体の並べ替え不可という制限がある。これらを解消し、自由な配置と直感的なドラッグ操作を実現する。加えて、ルーティン名の長いテキストに対応するため左カラムを横スワイプでリサイズ可能にする。

## 変更1: 統一順序モデル（スタック管理改善）

### 方針
`routine_nodes.sort_order`（未所属ルーティン）と `routine_stacks.sort_order`（スタック）を**共有の整数空間**で管理。displayRows構築時に両方を混合ソートする。**DBスキーマ変更なし**。

### Step 1: 型変更
**`packages/shared/src/lib/pageMapper.ts`**
- `Routine` に `displayOrder?: number` 追加（routine_nodes.sort_orderから取得）

### Step 2: useRoutines フック拡張
**`apps/mobile/hooks/useRoutines.ts`**

#### getRoutinesForNode 変更
- 各ルーティンに `displayOrder`（= routine_nodes.sort_order）を付与して返す

#### 新規関数3つ
| 関数 | 説明 |
|------|------|
| `reorderTopLevel(nodeId, orderedItems: {type, id}[])` | 未所属ルーティンとスタックを混合した全体順序を一括再付番。routine_nodes.sort_orderとroutine_stacks.sort_orderを同一整数空間で更新 |
| `moveRoutineToStackAtPosition(routineId, stackId, position)` | ルーティンを指定スタックの指定位置に直接移動。元スタックからの移動・未所属からの移動両対応 |
| `moveRoutineOutOfStack(routineId, topLevelPosition)` | スタックから外して指定のトップレベル位置に配置 |

#### PendingAction 新タイプ
`'reorder_toplevel'`, `'move_to_stack'`, `'move_out_of_stack'` を追加。syncPendingActionsにハンドラ追加。

#### 初回データ正規化
既存データはsort_orderが衝突する可能性があるため、`getRoutinesForNode`呼び出し時にトップレベル項目のorder値が重複していたら自動で再付番（unstacked routinesが先、stacksが後の既存順序を維持）。

### Step 3: displayRows 統一ソート
**`apps/mobile/components/routine/RoutineWeeklyTable.tsx`**

現在の「未所属→スタック」固定順を廃止し、unified sort:
```
topLevelItems = [
  ...unstackedRoutines.map(r => ({ kind: 'routine', order: r.displayOrder })),
  ...stacks.map(s => ({ kind: 'stack', order: s.sortOrder })),
].sort((a, b) => a.order - b.order)
```
→ 各itemを展開してdisplayRowsを構築（stackは boundary→header→routines→boundary に展開）

### Step 4: ドラッグロジック刷新

#### DropContext型による統一判定
```typescript
type DropContext =
  | { kind: 'top-level-between'; insertAtOrder: number }
  | { kind: 'into-stack'; stackId: string; atPosition: number }
  | null;
```

#### ドロップ判定ルール
| ドロップ先 | draggingRoutine | draggingStack |
|-----------|----------------|---------------|
| 未所属ルーティン行 | top-level-between（前後判定） | top-level-between |
| スタック内ルーティン行 | into-stack（位置計算） | top-level-between（スタック間） |
| スタックヘッダー | into-stack position=0 | top-level-between |
| 境界線(start/end) | top-level-between | top-level-between |

#### handleDragEnd の3パターン
1. **ルーティン → top-level-between**: 元がスタック内なら `moveRoutineOutOfStack`、元が未所属なら `reorderTopLevel`
2. **ルーティン → into-stack**: 同スタック内なら `reorderInStack`、異なるスタック/未所属なら `moveRoutineToStackAtPosition`
3. **スタック → top-level-between**: `reorderTopLevel`（スタックの位置変更）

### Step 5: スタックヘッダーの操作変更

| モード | 長押し操作 |
|--------|-----------|
| **デフォルト** | タイトルのインライン編集（ルーティンと同じUX） |
| **編集モード** | スタック全体をドラッグ移動（header+全ルーティン） |

- `draggingStackId` state追加
- 編集モードでstack headerにPanジェスチャー（activateAfterLongPress(200)）
- ドラッグ中はスタック内全行に `floatingRowStyle` + `opacity: 0.5` 適用
- Alert.alertは完全削除

### Step 6: Props変更
```typescript
// 削除: onReorder, onAddToStack, onRemoveFromStack
// 追加:
nodeId: string;
onReorderTopLevel?: (nodeId: string, orderedItems: Array<{ type: 'routine' | 'stack'; id: string }>) => void;
onMoveToStack?: (routineId: string, stackId: string, atPosition: number) => void;
onMoveOutOfStack?: (routineId: string, topLevelOrder: number) => void;
// 維持: onReorderInStack（スタック内並替は既存のまま）
```

### Step 7: PageContent.tsx 更新
- useRoutinesから新関数をdestructure
- 旧 `handleReorderRoutines` 削除、新コールバック3つに差替え
- `nodeId` propを RoutineWeeklyTable に渡す

---

## 変更2: 左カラム横スワイプリサイズ

### 方針
`LEFT_COL_W` 定数を `useSharedValue` に変換。デフォルトモードで左カラムに水平Panジェスチャーを追加。

### 実装
**`apps/mobile/components/routine/RoutineWeeklyTable.tsx`**

```typescript
const MIN_COL_W = 184;   // 現在と同じ初期値・最小値
const MAX_COL_W = screenWidth - 120;  // useWindowDimensions使用

const leftColWidthSV = useSharedValue(MIN_COL_W);
const startWidthSV = useSharedValue(MIN_COL_W);

// デフォルトモードのみ有効
const columnResizeGesture = !isActiveDaysMode ? Gesture.Pan()
  .activeOffsetX([-10, 10])   // 水平スワイプのみ検知
  .failOffsetY([-15, 15])     // 垂直はfail（スクロールに委譲）
  .onStart(() => { startWidthSV.value = leftColWidthSV.value; })
  .onUpdate((e) => {
    leftColWidthSV.value = clamp(startWidthSV.value + e.translationX, MIN_COL_W, MAX_COL_W);
  })
  .onEnd(() => { runOnJS(persistWidth)(leftColWidthSV.value); })
  : undefined;
```

- 左カラムを `<Animated.View>` に変更、`useAnimatedStyle` で width 適用
- `leftColumnRef` の型を `React.RefObject<Animated.View>` に
- AsyncStorageで幅を永続化（オプション）

### ジェスチャー競合回避
| モード | 左カラムのジェスチャー |
|--------|---------------------|
| デフォルト | 水平Pan（カラムリサイズ） |
| 編集 | 垂直Pan（行ドラッグ、各行ごと） |

`activeOffsetX` + `failOffsetY` で水平スワイプのみ検知。タップ・垂直スクロールに影響なし。

---

## 対象ファイル一覧

| ファイル | 変更 |
|---------|------|
| `packages/shared/src/lib/pageMapper.ts` | Routine に displayOrder 追加 |
| `apps/mobile/hooks/useRoutines.ts` | 新関数3つ + getRoutinesForNode改修 + PendingAction拡張 |
| `apps/mobile/components/routine/RoutineWeeklyTable.tsx` | displayRows統一ソート + ドラッグ刷新 + カラムリサイズ + Props変更 |
| `apps/mobile/components/page/PageContent.tsx` | Props差替え + nodeId追加 |

## 実装順序
1. 型変更（pageMapper.ts）
2. useRoutines: getRoutinesForNode改修 + 新関数3つ + PendingAction
3. RoutineWeeklyTable: displayRows統一ソート
4. RoutineWeeklyTable: ドラッグロジック刷新 + スタックヘッダー操作変更
5. RoutineWeeklyTable: カラムリサイズ
6. PageContent.tsx: Props更新
7. 旧Props・旧関数のクリーンアップ

## 検証方法
1. 未所属ルーティンとスタックを交互に配置 → リロード後も順序維持
2. ルーティンを別スタックの任意位置にドラッグ → 正しい位置に挿入
3. ルーティンをスタック外にドラッグ → 指定位置に未所属として配置
4. 編集モードでスタックヘッダー長押し → スタック全体がドラッグ移動
5. デフォルトでスタックタイトル長押し → インライン編集
6. デフォルトで左カラムを左スワイプ → カラム拡大、右スワイプ → 縮小
7. 編集モードでは横スワイプ無効（行ドラッグのみ）
8. オフライン時の操作がペンディングキューに入ること
