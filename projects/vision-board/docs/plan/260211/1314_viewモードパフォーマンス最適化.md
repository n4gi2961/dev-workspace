# View モード パフォーマンス最適化プラン

## Context

260210の閲覧モード実装時に追加した「最適化」が逆効果になり、**view モードが edit モードより重い**という問題が発生。原因分析の結果、3つの根本原因を特定した。

---

## 根本原因

### 原因1 (致命的): `handleOverlayToggleRoutine` が全ノードの React.memo を無効化

`index.tsx` の `handleOverlayToggleRoutine` の `useCallback` 依存配列に `cpOverrides`, `clearPercentMap`, `overlayDataMap` が含まれている。オーバーレイ操作のたびに:

1. `cpOverrides` が変更 → `overlayDataMap` 再計算（新参照）
2. `handleOverlayToggleRoutine` が新参照になる
3. BoardCanvas → 全 CanvasNode に伝播
4. **React.memo が全ノードで失敗 → 30+ ノード全再レンダー**

### 原因2 (高): `shouldRasterizeIOS` が過剰なGPUレイヤーを生成

view モードの各 Pressable に `shouldRasterizeIOS={!overlayActive}` を設定。20+ ノードが個別のGPUコンポジティングレイヤーになり、パン/ズーム時に毎フレーム全レイヤーをブレンドする必要がある。expo-image が独自キャッシュを持つため冗長。

### 原因3 (中): edit 専用コールバックが view モードの memo を汚染

view モードでも `onDragEnd`, `onResizeEnd` 等のコールバックが全ノードに渡されており、参照の不安定さが伝播。

---

## 変更ファイル

| # | ファイル | 変更内容 |
|---|---------|----------|
| 1 | `apps/mobile/app/(main)/(tabs)/index.tsx` | ref パターンでコールバック安定化 + overlayNodeIds を Set 化 |
| 2 | `apps/mobile/components/canvas/CanvasNode.tsx` | GPU rasterization 削除 |
| 3 | `apps/mobile/components/canvas/BoardCanvas.tsx` | view モードで安定 no-op コールバック + Set 型対応 |

---

## Step 1: コールバック安定化 (`index.tsx`)

volatile な値を ref 経由でアクセスし、`useCallback` の依存から除外する。

```typescript
// 追加 (cpOverrides, clearPercentMap, overlayDataMap の宣言後)
const cpOverridesRef = useRef(cpOverrides);
cpOverridesRef.current = cpOverrides;
const clearPercentMapRef = useRef(clearPercentMap);
clearPercentMapRef.current = clearPercentMap;
const overlayDataMapRef = useRef(overlayDataMap);
overlayDataMapRef.current = overlayDataMap;
```

```typescript
// handleOverlayToggleRoutine を書き換え — deps から volatile 値を除去
const handleOverlayToggleRoutine = useCallback(
  (nodeId: string, routine: Routine) => {
    const isChecking = !routine.history[today];
    if (isChecking) {
      const currentCp = cpOverridesRef.current[nodeId] ?? clearPercentMapRef.current[nodeId] ?? 100;
      const data = overlayDataMapRef.current[nodeId];
      if (data) {
        const newCp = calculateAfterToggle(currentCp, data.routines, [], routine.id, today, true);
        setCpOverrides((prev) => ({ ...prev, [nodeId]: newCp }));
      }
    }
    toggleRoutineCheck(routine.id, today);
  },
  [today, calculateAfterToggle, toggleRoutineCheck],
);
```

**安定性の根拠:**
- `today`: `useMemo(() => getTodayString(), [])` — セッション中不変
- `calculateAfterToggle`: `useCallback(..., [])` — 常に安定
- `toggleRoutineCheck`: `routines` 依存だがチェック操作1回に1回のみ変化（高頻度カスケードは断たれる）

## Step 2: overlayNodeIds を Set 化 (`index.tsx` + `BoardCanvas.tsx`)

```typescript
// index.tsx: overlayNodeIds の後に追加
const overlayNodeIdSet = useMemo(() => new Set(overlayNodeIds), [overlayNodeIds]);

// BoardCanvas への prop を overlayNodeIdSet に変更
```

```typescript
// BoardCanvas.tsx: prop型変更
overlayNodeIds?: Set<string>;

// 使用箇所 .includes() → .has()
overlayActive={overlayNodeIds?.has(node.id) ?? false}
```

## Step 3: GPU rasterization 削除 (`CanvasNode.tsx`)

view モード Pressable から2行を削除:
```diff
- shouldRasterizeIOS={!overlayActive}
- renderToHardwareTextureAndroid={!overlayActive}
```

## Step 4: view モードで安定 no-op コールバック (`BoardCanvas.tsx`)

```typescript
// コンポーネント冒頭に定数 no-op を定義
const NOOP_SELECT = useCallback((_: string) => {}, []);
const NOOP_VOID = useCallback(() => {}, []);
const NOOP_DRAG = useCallback((_id: string, _x: number, _y: number) => {}, []);
const NOOP_RESIZE = useCallback((_id: string, _w: number, _h: number, _x: number, _y: number) => {}, []);
const NOOP_DOUBLE_TAP = useCallback((_id: string) => {}, []);
```

ノード描画部分で mode に応じて切り替え:
```typescript
onSelect={mode === 'edit' ? onSelectNode : NOOP_SELECT}
onDeselect={mode === 'edit' ? handleCanvasDeselect : NOOP_VOID}
onDragEnd={mode === 'edit' ? handleDragEnd : NOOP_DRAG}
onResizeEnd={mode === 'edit' ? handleResizeEnd : NOOP_RESIZE}
onDoubleTap={mode === 'edit' ? handleDoubleTap : NOOP_DOUBLE_TAP}
```

---

## 検証方法

1. `npx tsc --noEmit` で新規エラーなし確認
2. Expo Go で動作確認:
   - view モードでパン/ズーム → スムーズさ改善確認
   - 画像タップ → オーバーレイ表示/非表示
   - オーバーレイ内ルーティンチェック → clearPercent 更新
   - ダブルタップ → 全オーバーレイ一括 ON/OFF
   - 長押し → ページ遷移
   - edit モード切り替え → ドラッグ/リサイズ/選択 全て正常
3. 改善後に edit モードと体感比較 — 同等以上であること
