# 流星抽選システム（Daily Meteor Lottery）実装プラン

## Context
現在、ルーティンチェック時に5%ランダムで流星が発火する。これを「ボード内ルーティン5個以上で1枠、以降10個ごとに+1枠。毎日0時にランダム抽選で当選ルーティンを決定し、当選チェック時に確定で流星が降る」仕様に変更。流星で得た星はStarStackで永続的に輝くビジュアルにする。

## 変更ファイル一覧

| 順序 | ファイル | 変更 |
|------|----------|------|
| 1 | `apps/mobile/lib/meteorLottery.ts` | **新規** — 決定論的RNG + `computeMeteorLottery()` |
| 2 | `hooks/useStarStack.ts` | `PendingStar`型導入、`queueStarColor`にmeteor引数、`meteorFlags`永続化+返却 |
| 3 | `hooks/useRoutines.ts` | 抽選結果計算 + `isMeteorWinner()` 公開 + queueStarColor呼び出し変更 |
| 4 | `app/(main)/(tabs)/ambient.tsx` | `METEOR_CHANCE`削除 → `isMeteorWinner`判定 |
| 5 | `app/(main)/(tabs)/index.tsx` | `isMeteorWinner`による流星+MeteorEffect追加 |
| 6 | `components/star-stack/StarMeshes.tsx` | 通常星+meteor星の2つのInstancedMesh |
| 7 | `components/star-stack/StarStackScene.tsx` | `meteorFlags`をStarMeshesに渡す |
| 8 | `app/(main)/star-stack/[boardId].tsx` | `meteorFlags`をStarStackSceneに渡す |

## Step 1: 決定論的抽選ロジック
**新規**: `apps/mobile/lib/meteorLottery.ts`

- `mulberry32` シードRNG（日付+boardIdをdjb2ハッシュ）
- `computeMeteorLottery(dateString, boardId, routineIds)` → `Set<string>`
- **スロット数**: `Math.max(0, Math.floor((count + 5) / 10))`
  - 0-4個 → 0枠、5-14個 → 1枠、15-24個 → 2枠、25-34個 → 3枠...
- Fisher-Yatesシャッフルで当選者選出
- 純粋関数（同日同ボード同ルーティン → 同じ結果）

## Step 2: useStarStack 型拡張 + meteor永続化
**変更**: `hooks/useStarStack.ts`

### データ型
```
PendingStar = { color: string; meteor: boolean }
```

### queueStarColor 拡張
- `queueStarColor(boardId, color, meteor=false)` — 第3引数追加
- AsyncStorage保存形式: `PendingStar[]`（後方互換: 読取時に`string`→`{color, meteor:false}`変換）

### color_counts 永続化拡張（JSONB、スキーマ変更不要）
- 旧: `[{color: "#8b5cf6", count: 5}]`
- 新: `[{color: "#8b5cf6", count: 5, meteorCount: 1}]`
- 復元時: 各色の先頭 `meteorCount` 個を `meteorFlags[i] = true` にセット
- `meteorCount` は undefined/0 の場合は0として扱う（後方互換）

### 返り値に追加
```
meteorFlags: boolean[]  // colors と同じ長さの並列配列
```

## Step 3: useRoutines に抽選組み込み
**変更**: `hooks/useRoutines.ts`

- `computeMeteorLottery` インポート
- `useMemo`で `meteorWinnerIds = computeMeteorLottery(today, boardId, Object.keys(routines).sort())`
- `isMeteorWinner(routineId): boolean` コールバック公開
- `toggleRoutineCheck` 内: `queueStarColor(boardId, color, isMeteorWinner(routineId))` に変更

## Step 4: ambient.tsx 変更
**変更**: `app/(main)/(tabs)/ambient.tsx`

- `METEOR_CHANCE` 定数を削除
- `useRoutines`から `isMeteorWinner` を取得
- `handleToggleRoutine` 内: `Math.random() < METEOR_CHANCE` → `isMeteorWinner(routine.id)`

## Step 5: index.tsx（ボード画面）に流星追加
**変更**: `app/(main)/(tabs)/index.tsx`

- `useRoutines`から `isMeteorWinner` を取得
- `handleOverlayToggleRoutine` 内: 当選時 `effects.triggerMeteor(routine.color)` 発火
- `MeteorEffect` コンポーネントをレンダーに追加

## Step 6: StarMeshes 2メッシュ化
**変更**: `components/star-stack/StarMeshes.tsx`

- propsに `meteorFlags: boolean[]` 追加
- 通常星用 InstancedMesh: 既存マテリアル（metalness: 0.3, roughness: 0.5）
- meteor星用 InstancedMesh: 発光マテリアル（metalness: 0.7, roughness: 0.2, emissive: 星の色, emissiveIntensity: 0.4）
- useFrame内で物理は1回だけstep。各星をフラグに基づいて2メッシュに振り分け
- 通常星は既存の色、meteor星はemissiveを星の色に設定して自発光

## Step 7-8: props伝播
- `StarStackScene` propsに `meteorFlags` 追加、`StarMeshes` に渡す
- `[boardId].tsx` で `useStarStack` から `meteorFlags` 取得、`StarStackScene` に渡す

## 検証方法
1. TypeScript: `npx tsc --noEmit` で新規エラーなし確認
2. 抽選ロジック: console.logで同日同ボードの結果が安定していることを確認
3. 画面テスト: 当選ルーティンチェック→流星確定、非当選→流星なし
4. StarStack: meteor星が通常星より明るく光っていることを3Dシーンで目視確認
