# 閲覧モード機能拡張: 全画面モード + ノードオーバーレイ

## Context

先ほど実装した閲覧/編集モードの切り替えに続き、閲覧モードの機能を充実させる。
- **全画面モード**: TopBar/TabBarを非表示にし没入体験。最小化ボタン + スクリーンショットボタン
- **ノードオーバーレイ**: 画像タップでFocusScreenと同様のオーバーレイ（ブラー、ルーティン、マイルストーン）を表示

## 依存ライブラリ追加

```bash
npx expo install react-native-view-shot expo-media-library
```

- `react-native-view-shot` — View をキャプチャして画像ファイルに変換
- `expo-media-library` — カメラロールに保存

---

## ステップ一覧

### Step 1: NavigationContext に tabBarVisible を追加
**ファイル**: `contexts/navigation.tsx`

```typescript
interface NavigationContextType {
  // ...既存
  tabBarVisible: boolean;
  setTabBarVisible: (visible: boolean) => void;
}
```

- デフォルト `true`
- 全画面モード進入時に `false`、退出時に `true`

### Step 2: _layout.tsx でTabBarを条件分岐
**ファイル**: `app/(main)/(tabs)/_layout.tsx`

```tsx
const { tabBarVisible } = useNavigation();
<Tabs tabBar={(props) => tabBarVisible ? <TabBar {...props} /> : null} ...>
```

### Step 3: index.tsx — 全画面モード + スクリーンショット
**ファイル**: `app/(main)/(tabs)/index.tsx`

新しいstate:
```typescript
const [isFullscreen, setIsFullscreen] = useState(false);
const [isCapturing, setIsCapturing] = useState(false);
const viewShotRef = useRef<ViewShot>(null);
```

全画面進入/退出:
```typescript
const enterFullscreen = useCallback(() => {
  selectNode(null);
  setIsFullscreen(true);
  setTabBarVisible(false);
}, [selectNode, setTabBarVisible]);

const exitFullscreen = useCallback(() => {
  setIsFullscreen(false);
  setTabBarVisible(true);
}, [setTabBarVisible]);
```

ステータスバー（時計・バッテリー・Wi-Fi等）を全画面時に非表示:
```tsx
import { StatusBar } from 'expo-status-bar';
// JSX内:
<StatusBar hidden={isFullscreen} />
```
`expo-status-bar`は既にインストール済み。全画面モード中はシステムUIが完全に消え、スクリーンショットも純粋なキャンバスのみになる。

スクリーンショット:
```typescript
const takeScreenshot = useCallback(async () => {
  setIsCapturing(true);
  // 次フレームでボタン非表示が反映されてからキャプチャ
  requestAnimationFrame(async () => {
    const uri = await viewShotRef.current?.capture?.();
    if (uri) {
      const { status } = await MediaLibrary.requestPermissionsAsync();
      if (status === 'granted') {
        await MediaLibrary.saveToAssetsAsync(uri);
        // 成功フィードバック（Haptics）
      }
    }
    setIsCapturing(false);
  });
}, []);
```

JSX構成:
```tsx
<View style={{ flex: 1, backgroundColor: '#121212' }}>
  {/* TopBar — 全画面時非表示 */}
  {!isFullscreen && <TopBar ... />}

  {/* Canvas + ViewShot wrapper */}
  <ViewShot ref={viewShotRef} style={{ flex: 1 }}>
    <BoardCanvas ... />
  </ViewShot>

  {/* 通常モード: zoom indicator + fullscreen button */}
  {!isFullscreen && (
    <>
      {/* 左下: 全画面ボタン（zoom indicatorの上） */}
      <View style={{ position:'absolute', left:16, bottom: tabBarHeight+16+40, zIndex:50 }}>
        <Pressable style={styles.smallButton}>
          <LucideIcon name="maximize" size={18} color="#FFF" />
        </Pressable>
      </View>
      {/* zoom indicator はBoardCanvas内に既存 */}
    </>
  )}

  {/* 全画面モード: minimize + screenshot */}
  {isFullscreen && !isCapturing && (
    <>
      <View style={{ position:'absolute', left:16, bottom:16+insets.bottom, zIndex:100 }}>
        <Pressable style={styles.smallButtonSubtle}>
          <LucideIcon name="minimize" size={16} color="rgba(255,255,255,0.5)" />
        </Pressable>
      </View>
      <View style={{ position:'absolute', right:16, bottom:16+insets.bottom, zIndex:100 }}>
        <Pressable style={styles.smallButtonSubtle}>
          <LucideIcon name="camera" size={16} color="rgba(255,255,255,0.5)" />
        </Pressable>
      </View>
    </>
  )}

  {/* 閲覧/編集モードボタン（全画面でないとき） */}
  {!isFullscreen && selectedBoardId && canvasMode === 'view' && (
    <FAB icon="pen-line" ... />
  )}
  {!isFullscreen && selectedBoardId && canvasMode === 'edit' && (
    <FABMenu ... />
  )}
</View>
```

**ZoomIndicator**: 全画面時は非表示にするため、BoardCanvasに`showZoomIndicator`propを追加するか、isFullscreenを渡す。

### Step 4: index.tsx — オーバーレイ用データフック追加
**ファイル**: `app/(main)/(tabs)/index.tsx`

```typescript
// 既存hooksに追加
const { pages, getPage } = usePages(user?.id ?? null);
const {
  getRoutinesForNode,
  toggleRoutineCheck,
  isRoutineActiveToday,
  reload: reloadRoutines,
} = useRoutines(selectedBoardId, user?.id ?? null);
const { recalculate, calculateAfterToggle } = useClearPercent();
```

clearPercent事前計算 (ambient.tsxと同じパターン):
```typescript
const imageNodes = useMemo(() => nodes.filter(n => n.type === 'image' && n.src), [nodes]);
const clearPercentMap = useMemo(() => {
  const map: Record<string, number> = {};
  for (const node of imageNodes) {
    const routines = getRoutinesForNode(node.id).filter(isRoutineActiveToday);
    map[node.id] = routines.length === 0 ? 100 : recalculate(routines, []);
  }
  return map;
}, [imageNodes, getRoutinesForNode, isRoutineActiveToday, recalculate]);

const [cpOverrides, setCpOverrides] = useState<Record<string, number>>({});
// ... 同clearPercentパターン
```

ページデータ事前読み込み:
```typescript
useEffect(() => {
  imageNodes.forEach(node => { if (!pages[node.id]) getPage(node.id); });
}, [imageNodes.map(n => n.id).join(',')]);
```

### Step 5: index.tsx — オーバーレイ状態管理
```typescript
const [overlayNodeIds, setOverlayNodeIds] = useState<string[]>([]);

const handleToggleNodeOverlay = useCallback((nodeId: string) => {
  setOverlayNodeIds(prev =>
    prev.includes(nodeId) ? prev.filter(id => id !== nodeId) : [...prev, nodeId]
  );
}, []);

// オーバーレイデータをnodeIdのmapとして構築
const overlayDataMap = useMemo(() => {
  const map: Record<string, OverlayData> = {};
  for (const nodeId of overlayNodeIds) {
    const page = pages[nodeId];
    const nodeRoutines = getRoutinesForNode(nodeId).filter(isRoutineActiveToday);
    map[nodeId] = {
      title: page?.title || '',
      routines: nodeRoutines,
      milestones: page?.milestones || [],
      clearPercent: cpOverrides[nodeId] ?? clearPercentMap[nodeId] ?? 100,
    };
  }
  return map;
}, [overlayNodeIds, pages, getRoutinesForNode, isRoutineActiveToday, cpOverrides, clearPercentMap]);

const handleOverlayToggleRoutine = useCallback((nodeId: string, routine: Routine) => {
  const isChecking = !routine.history[today];
  if (isChecking) {
    const currentCp = cpOverrides[nodeId] ?? clearPercentMap[nodeId] ?? 100;
    const data = overlayDataMap[nodeId];
    if (data) {
      const newCp = calculateAfterToggle(currentCp, data.routines, [], routine.id, today, true);
      setCpOverrides(prev => ({ ...prev, [nodeId]: newCp }));
    }
  }
  toggleRoutineCheck(routine.id, today);
}, [today, cpOverrides, clearPercentMap, overlayDataMap, calculateAfterToggle, toggleRoutineCheck]);
```

### Step 6: BoardCanvas — オーバーレイprops受け渡し
**ファイル**: `components/canvas/BoardCanvas.tsx`

Props追加:
```typescript
interface BoardCanvasProps {
  // ...既存
  overlayNodeIds?: string[];
  overlayDataMap?: Record<string, OverlayData>;
  onToggleNodeOverlay?: (nodeId: string) => void;
  onOverlayToggleRoutine?: (nodeId: string, routine: Routine) => void;
  today?: string;
  showZoomIndicator?: boolean; // 全画面時false
}
```

CanvasNodeに渡す:
```tsx
<CanvasNode
  ...
  overlayActive={overlayNodeIds?.includes(node.id) ?? false}
  overlayData={overlayDataMap?.[node.id]}
  onToggleOverlay={onToggleNodeOverlay}
  onOverlayToggleRoutine={onOverlayToggleRoutine}
  today={today}
/>
```

ZoomIndicator条件分岐:
```tsx
{showZoomIndicator !== false && <ZoomIndicator ... />}
```

### Step 7: CanvasNode — オーバーレイ描画
**ファイル**: `components/canvas/CanvasNode.tsx`

Props追加:
```typescript
interface CanvasNodeProps {
  // ...既存
  overlayActive?: boolean;
  overlayData?: OverlayData;
  onToggleOverlay?: (nodeId: string) => void;
  onOverlayToggleRoutine?: (nodeId: string, routine: Routine) => void;
  today?: string;
}
```

viewモードタップでオーバーレイトグル:
```typescript
const handleTapJS = useCallback(() => {
  if (mode === 'edit') {
    onSelect(node.id);
  } else if (node.type === 'image' && onToggleOverlay) {
    onToggleOverlay(node.id);
  }
}, [mode, node.id, node.type, onSelect, onToggleOverlay]);
```

画像にブラー適用:
```tsx
{node.type === 'image' && (
  <Image
    ...
    blurRadius={overlayActive && overlayData
      ? Math.round(12 * (1 - (overlayData.clearPercent ?? 100) / 100))
      : 0}
  />
)}
```

オーバーレイ描画（CanvasNode内、画像の上に重ねる）:
```tsx
{overlayActive && overlayData && (
  <NodeOverlay
    data={overlayData}
    nodeWidth={node.width}
    nodeHeight={node.height}
    today={today ?? ''}
    onToggleRoutine={(routine) => onOverlayToggleRoutine?.(node.id, routine)}
  />
)}
```

### Step 8: NodeOverlay コンポーネント（新規）
**ファイル**: `components/canvas/NodeOverlay.tsx`

FocusOverlayのUI構造を再利用。ノードの bounds 内に収まるよう調整。

```typescript
interface NodeOverlayProps {
  data: { title: string; routines: Routine[]; milestones: Milestone[]; clearPercent: number };
  nodeWidth: number;
  nodeHeight: number;
  today: string;
  onToggleRoutine: (routine: Routine) => void;
}
```

構造:
```tsx
<View style={{ position:'absolute', inset:0, borderRadius: cornerRadius, overflow:'hidden' }}>
  {/* Dark scrim */}
  <View style={{ ...absoluteFill, backgroundColor:'rgba(0,0,0,0.3)' }} pointerEvents="none" />
  {/* Scrollable content */}
  <ScrollView style={{ flex:1 }} contentContainerStyle={{ padding: 12 }}>
    {/* Title */}
    {/* Routines (tappable) */}
    {/* Milestones */}
  </ScrollView>
</View>
```

### Step 9: 閲覧/全画面モードのパフォーマンス最適化
**ファイル**: `components/canvas/CanvasNode.tsx`

閲覧モードでは画像の移動・リサイズが発生しないため、以下の最適化を適用:

**(a) GPUラスタライズ**
各CanvasNodeのルートViewに `shouldRasterizeIOS` / `renderToHardwareTextureAndroid` を追加。
ノードの見た目（ビュー階層全体）を単一GPUテクスチャに変換し、キャンバスのパン/ズーム時のコンポジティングコストを大幅削減。

```tsx
<Animated.View
  style={[...]}
  shouldRasterizeIOS={mode === 'view' && !overlayActive}
  renderToHardwareTextureAndroid={mode === 'view' && !overlayActive}
>
```

※overlayActive時はScrollViewなどインタラクティブ要素があるためラスタライズしない

**(b) GestureDetector → Pressable 切り替え**
editモードでは既存のGestureDetector（doubleTap, tap, pan composed gesture）を使用。
viewモードでは重いGestureDetectorを外し、軽量なPressableでタップ検出のみ行う。

```tsx
if (mode === 'view') {
  return (
    <Pressable onPress={handleTapJS}>
      <Animated.View ...>
        {/* node content + overlay */}
      </Animated.View>
    </Pressable>
  );
}
// editモード: 既存のGestureDetector構造を維持
return (
  <GestureDetector gesture={composedGesture}>
    ...
  </GestureDetector>
);
```

**(c) 静的positioning（viewモード）**
viewモードでは `useAnimatedStyle` + shared values の代わりに、直接 `left: node.x, top: node.y` を設定。
Reanimated のUIスレッドワークレット処理をスキップ。

```tsx
const viewStyle = mode === 'view'
  ? { left: node.x, top: node.y }     // 静的
  : animatedStyle;                      // Reanimated shared values
```

**(d) React.memo 最適化**
CanvasNodeを`React.memo`でラップし、`areEqual`比較関数を定義。
viewモードで変わり得るpropsのみ比較（overlayActive、overlayData.clearPercent）。

**効果の見込み:**
- GPUラスタライズ: ノード100枚でもパン/ズーム時のフレームレートを60fps維持
- GestureDetector除去: ジェスチャーシステムの処理負荷を1/3以下に
- 静的positioning: Reanimated UIスレッドの無駄な更新を完全排除

---

## 変更ファイル一覧

| 順序 | ファイル | 変更 |
|------|---------|------|
| 0 | package.json | `react-native-view-shot`, `expo-media-library` 追加 |
| 1 | `contexts/navigation.tsx` | `tabBarVisible`, `setTabBarVisible` 追加 |
| 2 | `app/(main)/(tabs)/_layout.tsx` | TabBar条件分岐 |
| 3 | `components/canvas/NodeOverlay.tsx` | **新規** — ノード内オーバーレイUI |
| 4 | `components/canvas/CanvasNode.tsx` | overlay props、viewモードタップ、ブラー、NodeOverlay描画 |
| 5 | `components/canvas/BoardCanvas.tsx` | overlay props受け渡し、ZoomIndicator条件 |
| 6 | `app/(main)/(tabs)/index.tsx` | 全画面モード、スクリーンショット、データhooks、オーバーレイ状態管理 |

## 検証方法

1. `npx tsc --noEmit` — 新規エラーなし
2. 動作確認:
   - 閲覧モードで左下maximize → 全画面（TopBar/TabBar消失）
   - 全画面で左下minimize → 通常に戻る
   - 全画面で右下camera → ボタン消失→SS撮影→カメラロール保存→ボタン復帰
   - 閲覧モードで画像タップ → 暗くなり、ブラー、タイトル/ルーティン/マイルストーン表示
   - ルーティンタップ → チェック切替、ブラー即時更新
   - 別の画像タップ → 2つ目のオーバーレイも表示（1つ目は維持）
   - 同じ画像再タップ → そのオーバーレイのみ閉じる
   - 全画面モードでも画像タップ → オーバーレイ正常表示
