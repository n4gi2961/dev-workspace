# RoutineWeeklyTable ドラッグジェスチャー修正計画

## Context（なぜ壊れているか）

長押し → 一瞬浮く → 即キャンセル の現象は以下の連鎖で発生している：

```
1. ユーザーが200ms長押し
2. activateAfterLongPress → Pan ジェスチャーがアクティブ (onStart 実行)
3. onStart 内で runOnJS(handleRoutineDragStart)(routineId) を呼ぶ
4. JS スレッドで setDraggingRoutineId(routineId) → React 再レンダリング
5. draggingRoutineId 変化
   → handleDragUpdate (deps に draggingRoutineId) → 新しい関数参照
   → handleDragEnd   (deps に draggingRoutineId) → 新しい関数参照
   → createDragGesture (deps に上記2つ)          → 新しい関数参照
6. renderRoutineRow 内で createDragGesture(routine.id, rowY) が呼ばれる
   → Gesture.Pan() が新しいオブジェクトとして生成される
7. GestureDetector に「新しいジェスチャーオブジェクト」が渡される
8. RNGH v2 がアクティブなジェスチャーをキャンセル ← これが原因
9. 一瞬浮いてすぐ止まる
```

前回の opacity:0 修正（GestureDetector をアンマウントしない）は必要だが、それだけでは不十分。
ジェスチャーオブジェクト自体が再生成されてしまうため同じ問題が起きる。

---

## 解決策：ジェスチャーオブジェクトを useMemo でルーティンIDごとにメモ化

### 核心アイデア

createDragGesture をレンダリング内で呼ぶのをやめ、
全ルーティンのジェスチャーを一度だけ useMemo で生成する。
コールバックの最新版は useRef 経由で橋渡しし、useCallback deps を不変にする。

```
routineGestures = useMemo(() => new Map<routineId, Gesture.Pan()>, [displayRows, rowOffsets])
                                     ↑ draggingRoutineId に依存しないので再生成されない
```

---

## 実装手順

### Step 1: Stable bridge パターンの導入
useRef に最新版を保持し、参照が変わらない bridge 関数を作る。

### Step 2: routineGestures を useMemo でメモ化
displayRows/rowOffsets にのみ依存 → drag 開始時に再生成されない

### Step 3: stackGestures も同様に useMemo 化

### Step 4: renderRoutineRow → routineGestures.get(routine.id)

### Step 5: renderStackHeader → stackGestures.get(row.stack.id)

### Step 6: createDragGesture / createStackDragGesture を削除

## 変更ファイル
- apps/mobile/components/routine/RoutineWeeklyTable.tsx のみ
